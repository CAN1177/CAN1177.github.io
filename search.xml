<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue基础知识总结]]></title>
    <url>%2F2020%2F05%2F11%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不可质疑，国内Vue使用者多于React使用者，其中Vue官网有一段这样的表述：“更抽象一点来看，我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件”。所以Vue相比React还是有一定的优势！ 但我写这篇“流水文章”,是为了面试也为了系统总结一下Vue相关知识。 基础篇谈谈你对MVVM的理解MVVM是 Model、View、 ModelView的缩写 Model: 数据模型层，可以在Model中定义数据修改和操作的业务逻辑View: 数据视图层，将数据模型转为UI展现出来Model-View: 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 然后再来看一下的图示：它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 Vue的生命周期beforeCreate（创建前） 组件实例被创建之初，组件的属性生效之前 created （创建后） 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用始，$el还没有显示出来 beforeMount (挂载前) 在挂载开始之前被调用：相关的 render 函数首次被调用 mounted （挂载后） el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 beforeUpdate （更新前）组件数据更新之前调用，发生在虚拟 DOM 打补丁之前 update （更新后） 组件数据更新之后 beforeDestroy （销毁前） 组件销毁前调用 destroyed （销毁后） 组件销毁后调用 盗一张图：生命周期示意图 什么是vue生命周期以及作用 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。 作用：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发哪几个钩子？ 答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。 DOM 渲染在 哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。 vue路由的钩子函数全局守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 使用方法 // main.js 入口文件import router from &apos;./router&apos;; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log(&apos;afterEach 全局后置钩子&apos;);&#125;); 关于to from next 这三个参数 to：route即将进入的目标路由对象 from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依-赖next方法的调用参数。可以控制网页的跳转。 组件内守卫： beforeRouteEnter 进入路由前beforeRouteUpdate (2.2) 路由复用同一个组件时beforeRouteLeave 离开当前路由时 这一部分自己不是很清楚，没必要强行写下去了，参考来自于： Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子] Vue的路由实现: hash模式 和 history模式 hash模式 浏览器url中带“#”号 用window.location.hash读取 不需要server端支持 history模式 采用HTML5的新特性 且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更 需要server端支持 说一下你对Vuex的理解 是干什么的 Vuex 是专门为 Vue.js 设计的状态管理库，它采用集中式存储管理应用的所有组件的状态。But，为什么需要状态管理：很多人最初喜欢用 Vue，React 这类框架，大概都是因为框架的响应式特性——当数据改变时，视图会进行重新渲染。这其实正是框架解决的最核心的问题。然而，对于简单的状态管理，一个简单的 store 模式就足够了，那么复杂的状态管理呢，所以，Vuex出现。 使用场景 多个视图使用于同一状态 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力 不同视图需要变更同一状态： 采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝，通常会导致无法维护的代码 Vuex图示 流程简化：View components -&gt; actions(dispatch方式) -&gt; mutations(commit方式) -&gt; state -&gt; View components, 而 getters则可以理解为computed，作为state的计算属性 state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据（必须是同步的） getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 谈谈你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 此部分，待更新❤️所以，频繁切换要用v-show，不频繁切换要用v-if，为了性能的提升 一些面试题v-show 与 v-if 有什么区别？ 区别 v-show会渲染dom树，用style=display:none隐藏 v-if 不会渲染dom树 结论 So，频繁切换要用v-show，不频繁切换要用v-if，为了性能的提升 computed 和 watch 的区别 computed 有缓存，data不变它也不变 watch 默认是浅监听，watch对于引用类型必须深度监听（要加属性条件）deep: true vue为什么不能检测数组的变化Vue2.0对于响应式数据的实现有一些不足： 无法检测数组/对象的新增 无法检测通过索引改变数组的操作 解决： Vue.set()方法 //针对第一个问题 Vue3.0采用Proxy替代了Object.definePropert 因为Object.DefineProperty的缺点，vue3 启用proxy 那么Object.definePropert的缺点是：1、深度监听，需要一次性递归到底，一次性计算量大2、新增和删除属性监听不到，需要Vue.set() 和 Vue.delete()3、无法原生监听数组，需要特殊处理 v-for的key值问题一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果 你有对 Vue 项目进行哪些优化？参考资料： 你有对 Vue 项目进行哪些优化？ （1）代码层面的优化 v-if 和 v-show 区分使用场景 computed 和 watch 区分使用场景 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if 长列表性能优化 事件的销毁 图片资源懒加载 路由懒加载 第三方插件的按需引入 优化无限列表性能 服务端渲染 SSR or 预渲染 （2）Webpack 层面的优化 Webpack 对图片进行压缩 减少 ES6 转为 ES5 的冗余代码 提取公共代码 模板预编译 提取组件的 CSS 优化 SourceMap 构建结果输出分析 Vue 项目的编译优化 （3）基础的 Web 技术的优化 开启 gzip 压缩 浏览器缓存 CDN 的使用 使用 Chrome Performance 查找性能瓶颈 待更新❤️]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue高级特性]]></title>
    <url>%2F2020%2F05%2F10%2FVue%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Vue为我们提供了很多高级特性，学习和掌握它们有助于提高我们的代码水平，本次小结来源于慕课网实战视频，网上搜索了一下，发先已经有同学写好了总结，那我就借花献佛： 高级特性前端进阶必会的六个Vue高级特性 除此之外，小小补充一下： watch进阶从我们刚开始学习Vue的时候，对于侦听属性，都是简单地如下面一般使用：watch:&#123; a()&#123; //doSomething &#125;&#125; 实际上，Vue对watch提供了很多进阶用法。 handler函数以对象和handler函数的方式来定义一个监听属性，handler就是处理监听变动时的函数：watch:&#123; a:&#123; handler:&apos;doSomething&apos; &#125;&#125;,methods:&#123; doSomething()&#123; //当 a 发生变化的时候，做些处理 &#125;&#125; handler有啥用？是多此一举么？用途主要有两点： 将处理逻辑抽象出去了，以method的方式被复用 给定义下面两个重要属性留出了编写位置 deep属性不知道你注意到了没有？ 当watch的是一个Object类型的数据，如果这个对象内部的某个值发生了改变，并不会触发watch动作！ 也就是说，watch默认是浅监听，watch对于值类型可以监听，但是引用类型必须深度监听（要加属性条件）deep: true 为解决这一问题，就要使用deep属性：watch:&#123; obj:&#123; handler:&apos;doSomething&apos;, deep:true &#125;&#125;,methods:&#123; doSomething()&#123; //当 obj 发生变化的时候，做些处理 &#125;&#125; deep属性默认为false，也就是我们常用的watch模式。 样式穿透我们知道，在单文件组件的style中使用 scoped 属性后，父组件的样式将不会渗透到子组件中。 不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。 如果你希望父组件的 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用深度选择器： &gt;&gt;&gt; 操作符。&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt; 上述代码将会编译成：.a[data-v-f3f3eg9] .b &#123; /* ... */ &#125; 但是，有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符，这两者都是 &gt;&gt;&gt; 的别名，实现同样的功能。 我们都知道，通过 v-html 创建的 DOM 内容不受 scoped 样式影响，可以通过深度作用选择器&gt;&gt;&gt;来为他们设置样式。 吧啦吧啦，继续更新❤️]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>watch</tag>
        <tag>scoped</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS伪类和伪元素]]></title>
    <url>%2F2020%2F05%2F08%2FCSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[先说一说为什么 css 要引入伪元素和伪类，以下是css2.1 Selectors 章节中对伪类与伪元素的描述： CSS introduces the concepts of pseudo-elements and pseudo-classes to permit formatting based on information that lies outside the document tree. 直译过来就是：css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释： 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 伪类与伪元素的区别VS可以这么理解： 它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是伪元素，反之，如果只需要在既有元素上添加类别的，就是伪类。 伪元素在一个选择器里只能出现一次，并且只能出现在末尾;伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。 常用伪类与伪元素 常用伪类 状态： :link 选择未访问的链接:visited 选择已访问的链接:hover 选择鼠标指针浮动在其上的元素:active 选择活动的链接:focus 选择获取焦点的输入字段 结构化： :not 一个否定伪类，用于匹配不符合参数选择器的元素 &lt;ul&gt; &lt;li class=&quot;first-item&quot;&gt;一些文本&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;/ul&gt; li:not(.first-item) &#123; color: orange;&#125; :first-child 匹配元素的第一个子元素 // 如下例，第一个&lt;li&gt; 元素的文本会变为橙色。&lt;ul&gt; &lt;li&gt;这里的文本是橙色的&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt;&lt;/ul&gt;li:first-child &#123; color: orange;&#125; :last-child 匹配元素的最后一个子元素 // 如下例，最后一个&lt;li&gt; 元素的文本会变为橙色&lt;ul&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;这里的文本是橙色的&lt;/li&gt;&lt;/ul&gt;li:last-child &#123; color: orange;&#125; :first-of-type 匹配属于其父元素的首个特定类型的子元素的每个元素// 如下例，第一个&lt;li&gt; 元素和第一个&lt;span&gt; 元素的文本会变为橙色&lt;ul&gt; &lt;li&gt;这里的文本是橙色的&lt;/li&gt; &lt;li&gt;一些文本 &lt;span&gt;这里的文本是橙色的&lt;/span&gt;&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt;&lt;/ul&gt;ul :first-of-type &#123; color: orange;&#125; :last-of-type 匹配元素的最后一个子元素。 如下例，最后一个&lt;li&gt; 元素的文本会变为橙色&lt;ul&gt; &lt;li&gt;一些文本&lt;span&gt;一些文本&lt;/span&gt; &lt;span&gt;这里的文本是橙色的&lt;/span&gt;&lt;/li&gt; &lt;li&gt;一些文本&lt;/li&gt; &lt;li&gt;这里的文本是橙色的&lt;/li&gt;&lt;/ul&gt;ul :last-of-type &#123; color: orange;&#125; 表单相关 :checked 匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。 // 如下例，当复选框被选中时，与其相邻的&lt;label&gt; 元素的背景会变成黄色&lt;input type=&quot;checkbox&quot;/&gt;&lt;label&gt;我同意&lt;/label&gt;input:checked + label &#123; background: yellow;&#125; :default 匹配默认选中的元素，例如：提交按钮总是表单的默认按钮。 // 如下例，只有提交按钮的背景变成了黄色&lt;form action=&quot;#&quot;&gt; &lt;button&gt;重置&lt;/button&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;:default &#123; background: yellow;&#125; :disabled 匹配禁用的表单元素 // 如下例，被禁用 input 输入框的透明度会变成 50%。&lt;input type=&quot;text&quot; disabled/&gt;:disabled &#123; opacity: .5;&#125; :empty 匹配没有子元素的元素。如果元素中含有文本节点、HTML 元素或者一个空格，则:empty 不能匹配这个元素。 如下例，:empty 能匹配的元素会变为黄色。 第一个元素中有文本节点，所以其背景不会变成黄色； 第二个元素中有一个空格，有空格则该元素不为空，所以其背景不会变成黄色； 第三个元素中没有任何内容，所以其背景会变成黄色； 第四个元素中只有一个注释，此时该元素是空的，所以其背景会变成黄色； &lt;div&gt;这个容器里的背景是橙色的&lt;/div&gt;&lt;div&gt; &lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;!-- This comment is not considered content --&gt;&lt;/div&gt;div &#123; background: orange; height: 30px; width: 200px;&#125; div:empty &#123; background: yellow;&#125; :valid 匹配条件验证正确的表单元素。 如下例，当 email 输入框内的值符合 email 格式时，输入框的边框会被设为绿色。 &lt;input type=&quot;email&quot;/&gt;input[type=email]:valid &#123; border: 1px solid green;&#125; 常用伪元素 ::before/:before :before 在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。&lt;h1&gt;World&lt;/h1&gt;h1:before &#123; content: &quot;Hello &quot;;&#125; ::after/:after :after 在被元素后插入内容，其用法和特性与:before 相似。 ::first-letter/:first-letter :first-letter 匹配元素中文本的首字母。被修饰的首字母不在文档树中。h1:first-letter &#123; font-size: 5em;&#125; ::first-line/:first-line :first-line 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。p:first-line &#123; background: orange;&#125; ::selection ::selection 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加-moz 前缀。该伪元素只支持双冒号的形式。::-moz-selection &#123; color: orange; background: #333;&#125; ::selection &#123; color: orange; background: #333;&#125; ::placeholder ::placeholder 匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。 该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。 在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式。&lt;input type=&quot;email&quot; placeholder=&quot;name@domain.com&quot;&gt;input::-moz-placeholder &#123; color:#666;&#125; input::-webkit-input-placeholder &#123; color:#666;&#125; /* IE 10 only */input:-ms-input-placeholder &#123; color:#666;&#125; /* Firefox 18 and below */input:-moz-input-placeholder &#123; color:#666;&#125; 参考文章 ❤️&lt;总结伪类与伪元素 CSS伪类与CSS伪元素的区别及由来 v]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>伪类</tag>
        <tag>伪元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端http面试知识点]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%89%8D%E7%AB%AFhttp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[状态码:1xx Informational（信息状态码） 接受请求正在处理2xx Success（成功状态码） 请求正常处理完毕3xx Redirection（重定向状态码） 需要附加操作已完成请求4xx Client Error（客户端错误状态码） 服务器无法处理请求5xx Server Error（服务器错误状态码） 服务器处理请求出错 Http与Https的区别:HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头HTTP 是不安全的，而 HTTPS 是安全的HTTP 标准端口是80 ，而 HTTPS 的标准端口是443在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层HTTP 无法加密，而HTTPS 对传输的数据进行加密HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书 一次完整的HTTP请求所经历的步骤：HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤： 建立TCP连接 在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。 Web浏览器向Web服务器发送请求行 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。 Web浏览器发送请求头 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。 Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。 Web服务器发送应答头 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。 Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 Web服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接 不得不提“网络模型” 关于iso/osi7层网络模型的理解：点我带你去 Accept和Content-TypeAccept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。 Accept: text/htmlAccept: image/*Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 1.Accept属于请求头， Content-Type属于实体头。Http报头分为通用报头，请求报头，响应报头和实体报头。请求方的http报头结构：通用报头|请求报头|实体报头响应方的http报头结构：通用报头|响应报头|实体报头 2.Accept代表发送端（客户端）希望接受的数据类型。比如：Accept：text/xml;代表客户端希望接受的数据类型是xml类型 Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。比如：Content-Type：text/html;代表发送端发送的数据格式是html。 二者合起来，Accept:text/xml；Content-Type:text/html即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。 持续更新 ❤️]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写call、apply、bind]]></title>
    <url>%2F2020%2F04%2F20%2F%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%2F</url>
    <content type="text"><![CDATA[说到call、apply、bind首先是改变this指向的问题（ES5中），其次它们之间的区别，最后光说不练假把式，手写call、apply、bind！ this指向在 ES5 中，其实 this 的指向，始终坚持一个原理： this 永远指向最后调用它的那个对象（也就是说：this取什么值是在函数执行时确定的，不是在函数定义时确定的） 看个例子： var name = &quot;如来佛祖&quot;;function a() &#123; var name = &quot;孙悟空&quot;; console.log(this.name); // 如来佛祖 console.log(&quot;inner:&quot; + this); //inner:[object Window]&#125;a();console.log(&quot;outer:&quot; + this); //outer:[object Window] 很简单，像上面说的 this取什么值是在函数执行时确定的，最后k看调用 a 的地方 a()，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。 再来一个： var name = &quot;如来佛祖&quot;;var a = &#123; name: &quot;孙悟空&quot;, fn: function() &#123; name: &quot;猪八戒&quot;, console.log(this.name); //孙悟空 &#125;&#125;;window.a.fn(); 为什么，这里会是孙悟空，而不是猪八戒呢，或者为什么不是如来佛祖呢，因为如上面的那句话：this取什么值是在函数执行时确定的，因为，window.a.fn()就表示，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，所以name是孙悟空。 改变this 的指向 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind 使用 ES6 的箭头函数var name = &quot;如来佛祖&quot;;var a = &#123; name: &quot;孙悟空&quot;, func1: function() &#123; console.log(this.name); &#125;, func2: function() &#123; setTimeout(() =&gt; &#123; this.func1(); &#125;, 100); &#125;&#125;;a.func2(); //孙悟空 在函数内部使用 _this = thisvar name = &quot;如来佛祖&quot;;var a = &#123; name: &quot;孙悟空&quot;, func1: function() &#123; console.log(this.name); &#125;, func2: function() &#123; var _this = this; setTimeout(function() &#123; _this.func1(); &#125;, 100); &#125;&#125;;a.func2(); //孙悟空 使用 apply、call、bind使用 apply var a = &#123; name: &quot;孙悟空&quot;, func1: function() &#123; console.log(this.name); &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1(); &#125;.apply(a), 100 ); &#125; &#125;; a.func2(); 使用 call var a = &#123; name: &quot;孙悟空&quot;, func1: function() &#123; console.log(this.name); &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1(); &#125;.apply(a), 100 ); &#125; &#125;; a.func2(); //孙悟空 使用bind var a = &#123; name: &quot;孙悟空&quot;, func1: function() &#123; console.log(this.name); &#125;, func2: function() &#123; setTimeout( function() &#123; this.func1(); &#125;.bind(a)(), 100 ); &#125; &#125;; a.func2(); //孙悟空 call、apply、bind的区别 call语法 fun.call(thisArg[, arg1[, arg2[, …]]]) apply语法 fun.apply(thisArg, [argsArray]) bind语法 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 手写call、apply、bind以下内容部分来自来自 Medium 手写call Function.prototype.myOwnCall = function(someOtherThis) &#123; someOtherThis = someOtherThis || global; var uniqueID = &quot;00&quot; + Math.random(); while (someOtherThis.hasOwnProperty(uniqueID)) &#123; uniqueID = &quot;00&quot; + Math.random(); &#125; someOtherThis[uniqueID] = this; const args = []; // arguments are saved in strings, using args for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(&quot;arguments[&quot; + i + &quot;]&quot;); &#125; // strings are reparsed into statements in the eval method // Here args automatically calls the Array.toString() method. var result = eval(&quot;someOtherThis[uniqueID](&quot; + args + &quot;)&quot;); delete someOtherThis[uniqueID]; return result; &#125;; 手写apply Function.prototype.myOwnApply = function(someOtherThis, arr) &#123; someOtherThis = someOtherThis || global; var uniqueID = &quot;00&quot; + Math.random(); while (someOtherThis.hasOwnProperty(uniqueID)) &#123; uniqueID = &quot;00&quot; + Math.random(); &#125; someOtherThis[uniqueID] = this; var args = []; var result = null; if (!arr) &#123; result = someOtherThis[uniqueID](); &#125; else &#123; for (let i = 1, len = arr.length; i &lt; len; i++) &#123; args.push(&quot;arr[&quot; + i + &quot;]&quot;); &#125; result = eval(&quot;someOtherThis[uniqueID](&quot; + args + &quot;)&quot;); &#125; delete someOtherThis[uniqueID]; return result;&#125;; 手写bind // 模拟 bind Function.prototype.bind1 = function() &#123; //arguments获取一个函数所有的参数，它是一个列表 // 将参数拆解为数组 const args = Array.prototype.slice.call(arguments); // 获取 this（数组第一项） const t = args.shift(); // 好比fn1.bind(...) 中的 fn1 或者下面的_this=this // const self = this; _this=this // 返回一个函数（bind本来是返回一个函数） return function() &#123; // apply的第一个参数就是this return _this.apply(t, args); &#125;; &#125;; 待更新❤️，后续继续补充]]></content>
      <categories>
        <category>学习</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>call</tag>
        <tag>bind</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[href和src有什么区别]]></title>
    <url>%2F2020%2F04%2F10%2Fhref%E5%92%8Csrc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[关于这两个属性，相比前端同学都不陌生，也是前端面试的基础知识，那么知其然知其所以然，我们来聊聊它们之间的细微差距！ href VS src： href href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用而不是@import &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt; src src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕，这也是script标签之所以放底部的原因 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 结论：So，两者的加载性能不同，href速度优于src!]]></content>
      <categories>
        <category>学习</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>href</tag>
        <tag>src</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之问题集]]></title>
    <url>%2F2020%2F03%2F12%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%97%AE%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[半年多的前端工作经验，由于个人原因，从上家公司离职，然后一边面试一边总结经验，这篇文章会持续记录自己面试遇到的一些问题和解决措施，并且做个自我监督，奥力给！ vue为什么不能检测数组的变化Vue2.0对于响应式数据的实现有一些不足： 无法检测数组/对象的新增 无法检测通过索引改变数组的操作。 详情链接 为什么用Object.prototype.toString.call(obj)检测对象类型?详情链接 实现promise.all方法Promise.all()通常在启动多个异步任务并发运行并为其结果创建承诺之后使用，以便人们可以等待所有任务完成。 详情链接 Sass 和 SCSS 有什么区别？Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 参考文章：CSS、Sass、Scss，以及sass和scss的区别 来个“劲爆的”，你知道forEach()、与map()的区别吗？说实话，面试的时候没有答上来，我只知道：它们都是用来遍历的，但是具体区别呢，返回值呢，那时脑子短路，真没说出个所以然！ So，万丈高楼平地起，基础不扎实，会白白浪费一个offer！ 唠叨罢了，还是先看看到底怎么用吧，上网查了一下，发现了两张图和一段代码，然后自己觉得这些也就够了： 图一： 图二： 一段代码： 代码要比口语来得更清晰，很简单的实现，仅仅实现功能，没做容错处理和特别严格的上下文处理。 Array.prototype.map = function (fn) &#123; var resultArray = []; for (var i = 0,len = this.length; i &lt; len ; i++) &#123; resultArray[i] = fn.apply(this,[this[i],i,this]); &#125; return resultArray;&#125;Array.prototype.forEach = function (fn) &#123; for (var i = 0,len = this.length; i &lt; len ; i++) &#123; fn.apply(this,[this[i],i,this]); &#125;&#125;Array.prototype.reduce= function (fn) &#123; var formerResult = this[0]; for (var i = 1,len = this.length; i &lt; len ; i++) &#123; formerResult = fn.apply(this,[formerResult,this[i],i,this]); &#125; return formerResult;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域粗解]]></title>
    <url>%2F2020%2F03%2F01%2F%E8%B7%A8%E5%9F%9F%E7%B2%97%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是跨域 ajax 请求时浏览器要求当前网页必须和server同源（为了安全起见），必须遵循同源策略，如果违背去请求数据那就是跨域 那么什么是同源策略同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现 简而言之： 同源就是，同源就是 协议、域名、端口三者必须一致 跨域解决方案JSONP 跨域由于浏览器未做限制，script标签可以跨域请求资源 优点 使用简便，没有兼容性问题，目前最流行的一种跨域方法。 缺点 1、只支持 GET 请求2、由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码3、要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题 CORS（跨域资源共享） 解析： CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持，整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 SO，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 请求方式 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request） 请参考阮一峰的网络日志 CORS VS JSONPJSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 IMG与CSS由于浏览器未做限制，img标签和css也可以跨域请求资源 &lt;img src=&quot;图片跨域地址&quot;/&gt;&lt;link herf=&quot;跨域的css地址&quot;/&gt; 服务器代理浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。服务器代理是万能的。举个栗子🌰：Nginx代理 注意：除上述部分，跨域解决方式还有：document.domain 跨域、window.name 跨域、location.hash 跨域、postMessage 跨域]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise和async await详解]]></title>
    <url>%2F2019%2F07%2F30%2FPromise%E5%92%8Casync%20await%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在7月份写一个项目的管理平台时，遇到的关于promise与async await的问题，下面有很好的讲解： 点击这里]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[egg.js 写接口]]></title>
    <url>%2F2019%2F06%2F24%2Feggjs%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[egg.js 写接口一般可以归纳为三个部分：引入控制器, 新建类，导出类 const Controller = require(&apos;egg&apos;).Controller;class NewsController extends Controller&#123; //类名大写 async list()&#123; // async await 异步 const dataList = await this.data(); this.ctx.body = &#123; code:0, masg:&apos;success!&apos;, data:dataList &#125;; &#125; async data()&#123; return &#123; list:[ &#123; id: 1, title: &apos;news1&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce26578e0e5549312.png&apos; &#125;, &#123; id: 2, title: &apos;news2&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657a0e01277224.png&apos; &#125;, &#123; id: 3, title: &apos;news3&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657b67be250185.png&apos; &#125;, ] &#125; &#125;&#125;module.exports = NewsController; //别忘了导出类,注意类名的写法，后面加Controller 之后，打开app/router.js 新建一个接口 router.get(&#39;/list&#39;, controller.news.list); 注意路径不要写错 module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&apos;/&apos;, controller.home.index); router.get(&apos;/list&apos;, controller.news.list);&#125;; 完成之后就可以打开我们的前端项目进行接口请求，可以看到返回的内容。成功~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>egg.js</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法总结！]]></title>
    <url>%2F2019%2F06%2F13%2Fmarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题一级标题二级标题三级标题四级标题五级标题六级标题二、字体加粗 易灿 斜体 易灿 斜体加粗 乌拉 删除线 蛮吉 三、引用 引用一 引用二 引用三 一个&gt; 一条线 四、分割线三个以上的 * 号和-号都可以： -------******** 效果如下： 五、图片图片三种方式： 插入本地图片 (本文件放于桌面，照一张图片，重命名1.jpg就可以显示) 插入网络图片 把图片存入markdown文件 用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 格式如下： ![avatar][base64str] [base64str]: data:image/png;base64,iVBORw0….. 但是，base64的图片编码如何得来： 使用python将图片转化为base64字符串 import base64f=open(&apos;723.png&apos;,&apos;rb&apos;) #二进制方式打开图文件ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码f.close()print(ls_f) base64字符串转化为图片 import base64bs=&apos;iVBORw0KGgoAAAANSUhEUg....&apos; # 太长了省略imgdata=base64.b64decode(bs)file=open(&apos;2.jpg&apos;,&apos;wb&apos;)file.write(imgdata)file.close() 六、超链接 语法： [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 百度 CAN7我的博客 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 &lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 百度 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 - 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果： 列表1 列表2 列表3 有序列表 语法：数字加点 1.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 姓名 兵器 排行 刘备 双锏 大哥 关羽 青龙偃月刀 二哥 张飞 长矛 三弟 姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 注：姓名之后没有空格 九、代码语法：单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 &lt;script&gt; var _hmt = _hmt || []; (function() &#123; var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?0c0e9d9b1e7d617b3e6842e85b9fb068"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); &#125;)(); &lt;/script&gt; var _hmt = _hmt || []; 十、流程图语法： ​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 效果：```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; `]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO3！]]></title>
    <url>%2F2019%2F04%2F24%2FJavaScript%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript基础面试题1、js基本的数据类型：Number、String、Boolean、Null、Undefined Object 是 JavaScript 中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error新类型：Symbol 2、Ajax使用全称 ： Asynchronous Javascript And XML所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。创建Ajax的过程：1) 创建XMLHttpRequest对象（异步调用对象） var xhr = new XMLHttpRequest(); 2) 创建新的Http请求（方法、URL、是否异步） xhr.open(‘get’,’example.php’,false); 3) 设置响应HTTP请求状态变化的函数。onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。4) 发送http请求 xhr.send(data); 5) 获取异步调用返回的数据注意：1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。3) 尽量减少ajax请求次数4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。 3、JavaScript有几种类型的值 画一下他们的内存图 基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。 两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 4、 什么是window对象? 什么是document对象?window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。 5、 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用event.stopPropagation()方法可阻止冒泡;（旧IE的方法 ev.cancelBubble = true;） 6、 什么是闭包（closure），为什么要用它？闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。优点：避免全局变量污染。缺点：容易造成内存泄漏。例子： function makeFunc() &#123; var name = &quot;Mozilla&quot;; function displayName() &#123; console.log(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); //输出Mozilla myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。 7 、对JSON的了解？全称：JavaScript Object NotationJSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。 两个函数：JSON.parse(str)解析JSON字符串 把JSON字符串变成JavaScript值或对象 JSON.stringify(obj)将一个JavaScript值(对象或者数组)转换为一个 JSON字符串 eval(‘(‘＋json＋’)’)用eval方法注意加括号 而且这种方式更容易被攻击 8、documen.write和 innerHTML的区别document.write()只能重绘整个页面 setTimeout(function()&#123; document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);&#125;, 5000); 或 window.onload = function() &#123; document.write(&quot;HI&quot;); innerHTML可以重绘页面的一部分 9、DOM操作（1）创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点（2）添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点（3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 10、数组对象有哪些原生方法，列举一下pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRightforEach、map、filter、every、some 11、那些操作会造成内存泄漏全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用 12、响应事件onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO2！]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端面试基础一、CSS1、css盒模型 w3c盒子模型：属性width,height只包含内容content，不包含border和padding 属性width,height包含border和padding，指的是content+padding+border 2、居中布局水平居中元素： 通用方法，元素的宽高未知 方式一：CSS3 transform .parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; 方式二：Flex 布局 .parent &#123; display: flex; justify-content: center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可水平居中。 居中的元素为常规文档流中的内联元素(display: inline) 常见的内联元素有：span, a, img, input, label 等等 .parent &#123; text-align: center;&#125; 此方法同样适用于 display: inline-block 的元素。 居中的元素为常规文档流中的块元素(display: block) 常见的块元素：div, h1~h6, table, p, ul, li 等等 方式一：设置 margin .parent &#123; width: 100%;&#125;.child &#123; width: 600px; height: 50px; margin: 0 auto; background: #999;&#125; 此方法只能进行水平的居中，且对浮动元素或绝对定位元素无效。 方式二：修改为 inline-block 属性 .parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 居中的元素为浮动元素 .child &#123; width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;&#125; 居中的元素为绝对定位元素 方式一： .parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 50%; margin-left: -50px;&#125; 方式二： .parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中元素： 通用方法，元素的宽高未知 方式一：CSS3 transform .parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 方式二：Flex 布局 .parent &#123; display: flex; align-items: center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。 居中元素为单行文本 .text &#123; line-height: 200px; height: 200px;&#125; 把文字的 line-height 设为文字父容器的高度，适用于只有一行文字的情况。 已知元素宽高 方式一： .parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 方式二： .parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 0; bottom: 0; height: 100px; margin: auto 0;&#125; 垂直居中元素： 1. 绝对居中定位 div &#123; width: 100px; height: 100px; margin: auto; position: fixed; //absolute is ok top: 0; right: 0; bottom: 0; left: 0;&#125; 优点： 不仅可以实现在正中间，还可以在正左方，正右方 元素的宽高支持百分比 % 属性值和 min-/max- 属性 可以封装为一个公共类，可做弹出层 浏览器支持性好 2. 负边距居中 .child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 特点： 良好的跨浏览器特性,兼容 IE6 - IE7 灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性 3. Transform 定位 .child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 特点： 内容可自适应，可以封装为一个公共类，可做弹出层 可能干扰其他 transform 效果 4. Flexbox 布局 .parent &#123; display: flex; justify-content: center; align-items: center;&#125; 这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。 5. table-cell 居中 .parent &#123; display: table-cell; vertical-align: middle; text-align: center; width: 200px; height: 200px; border: 1px solid red;&#125;.child &#123; width: 100px; height: 100px; display: inline-block; background-color: #03f;&#125; 适用于子元素 display 为 inline-block, inline 类型的元素，需要已知父元素的宽高，且父元素的宽高不能设为百分比数。 6. font-size 配合 vertical-align 实现垂直居中 .parent &#123; font-size: 175.4px; height: 200px; text-align: center;&#125;.child &#123; vertical-align: middle; display: inline-block; font-size: 12px; width: 50px; height: 50px; background-color: #00f;&#125; 该方法的要点是给父元素设一个合适的 font-size 的值，这个值的取值为该父元素的高度除以 1.14 得到的值，并且子元素必须 是一个 inline 或 inline-block 元素，需要加上 vertical-align: middle 属性。使用这种方法，子元素的宽度或高度都不必知道。 具体原理可以上网搜 vertical-align 垂直居中。 7. 文本内容**居中** text &#123; height: 100px; line-height: 100px; text-align: center;&#125; 3、清除浮动分析HTML结构： &lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt;&lt;/div&gt; 分析CSS代码样式： .box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px; &#125; .div1 &#123; width: 100px; height: 100px; background: darkblue; float: left; &#125; .div2 &#123; width: 100px; height: 100px; background: darkgoldenrod; float: left; &#125; .div3 &#123; width: 100px; height: 100px; background: darkgreen; float: left; &#125; 什么是浮动 浮动：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来 一：添加新元素，应用clear：both;HTML： &lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt; CSS： .clear &#123; clear: both; height: 0; line-height: 0; font-size: 0 &#125; 二：父级div定义overflow：auto;HTML: &lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt;&lt;/div&gt; CSS： .box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px; overflow: auto; zoom: 1; /*zoom: 1; 是在处理兼容性问题 */&#125; 三：在父级样式添加伪元素:after或者:before（推荐）HTML: html &lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt; &lt;/div&gt; CSS: .box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px;&#125;.box:after&#123; content: ''; display: block; clear: both;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP相关面试题总结！]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%89%8D%E7%AB%AFhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP相关面试题总结1、HTTP中常用的请求方法有哪些？哪些请求方法是安全的？为什么？答：常用的请求方法有GET,POST,HEAD,PUT,DELETE。其中GET和HEAD是安全的，因为其他的三个方法都会对服务器产生动作，GET和HEAD只是请求数据，POST和POUT都会给服务端发送报文主体 2、HTTP中POST和GET方法有什么区别？答：主要有以下几点区别：GET请求在页面后退的时候是无害的（即不会再次发送请求），而POST会再次发送请求GET请求的参数是放在请求的URL中，而POST方法是放在请求体中GET请求在URL中传递参数时会有长度限制，而POST无限制（不是绝对的，只是相对来说）GET请求会被浏览器主动缓存，而POST不会GET请求的参数会保存在浏览器中，而POST的参数不会保存在浏览器中 3、在浏览器中输入URL到页面进行渲染的过程中发生了什么？答：可以参考下面这张图理解：（参考《HTTP权威指南》） 浏览器解析主机名 DNS进行域名解析，即将语义化的主机名转换成IP地址 浏览器获得端口号 浏览器根据得到的ip地址和端口号发起TCP连接 浏览器发起HTTP请求 浏览器读取服务器返回的响应报文 浏览器对返回的HTML进行渲染 浏览器断开TCP连接 4、请简单描述一下TCP的三次握手和四次挥手的过程，两次握手可以吗？答：详细解答 TCP的三次握手：a.客户端发送一个SYN报文请求连接，变为SYN_SEND状态b.服务端接收到客户端发送SYN包，进行确认过后，发送ACK报文，变为SYN_RECV状态c.客户端接收到服务端的SYN和ACK报文后，发送ACK包进行确认，然后客户端和服务端都变成ESTABLISHED状态 TCP的四次挥手：a.客户端没有数据要发送了，请求关闭连接，发送一个FIN报文，并进入FIN_WAIT_1状态b.服务端接收到FIN报文后，发送ACK报文，然后进入CLOSE_WAIT状态；客户端接收到ACK报文后，进入FIN_WAIT_2状态c.服务端判断是否有数据发送给客户端，如果有的话，就将数据发送给客户端，再发送FIN报文；没有的话就直接发送FIN报文，请求关闭连接，然后进入LAST_ACK状态；d.客户端接收到服务端的FIN报文后，发送ACK报文，然后客户端进入TIME_WAIT状态；服务端接收到ACK报文后，关闭连接，变为CLOSED状态，客户端在2MSL后依然没有收到回复，也可以关闭连接了。 两次握手可以吗？ 不可以，三次握手主要是防止已经过期的请求再次连接到服务端而占用资源造成浪费。如果是两次握手的话，假设主机A在发送第一次请求时，由于网络滞留的问题卡住了，很久后没有收到主机B的确认信息，于是又发送了第二次请求。过了一段时间后，第一个请求到达了主机B，主机B以为是一次新的请求，就返回确认信息，但是由于没有第三次握手，只要主机B发出确认信息，就会连接，这个时候主机B一直等待着主机A发送信息，就会造成资源浪费。 5、TCP和UDP的区别是什么？答：主要有以下几个方面的区别：a.连接方面：TCP是面向连接的，而UDP是无连接的，即UDP在传输数据之前不需要像TCP那样3次握手建立连接b.可靠性：TCP比UDP更可靠，TCP可以保证不丢包，会按照顺序传输数据，这也是导致c.资源消耗：TCP对系统资源要求比较高，并且消耗资源比较大；UDP要求不高，但是在网络质量不好的情况下比较容易丢包，消耗资源相对比较小d.适用场景：TCP适用于HTTP，FTP以及邮件传输等等；而UDP比较适合于语音，视频等e.速度问题：TCP传输速度比较慢，效率低，在握手和挥手的过程中会占用很多时间；UDP传输速度比较快，由于是无连接的，只有传输数据的过程f.安全性：安全性和可靠性是不同的概念，由于TCP的机制比较多，更容易受到攻击；UDP相对来说就比较安全，但是也不能避免受到攻击g.连接形式：TCP是只能一对一的发送，而UDP可以是一对一，一对多，多对多 6、HTTP中常见的状态码有哪些？分别表示什么意思？答：常见的状态码有：200：接收并响应成功301：请求的资源已经换了URL，需要重新请求（永久重定向）302：请求的资源临时换了URL，需要重新请求（临时重定向）304：在缓存中有该资源，可以直接获取403：该资源禁止访问404：该资源不存在 7、HTTP有什么特点？HTTP有什么缺点？答：特点 * 简单高效 * 灵活 * 无连接 * 无状态答：有以下缺点： * 一条连接上只能发送一个请求 * 请求只能从客户端开始，客户端不可以接收除响应之外的指令 * 请求/响应首部未经压缩就发送，首部信息越多造成的延迟越大 * 发送冗长的首部，每次互发相同的首部造成很大的浪费 * 通信使用明文，内容可能会被窃听 * 不验证通信方的身份，有可能会遭遇伪装 * 无法验证报文的完整性，有可能遭遇篡改 8、请描述AJAX实现原理答：AJAX的实现核心在于XMLHttpRequest这个API，主要分为以下几个步骤（参考文章：https://segmentfault.com/a/1190000017176090）：创建XMLHttpRequst对象初始化传进来的参数使用open方法发送请求接收请求并调用onreadystatechange方法对返回成功以及失败的情况进行定义 9、HTTP和HTTPS的关系以及HTTPS的实现原理答：* HTTPS和HTTP的关系 HTTPS在HTTP的基础上加上了SSL协议，使得HTTP通信更加安全。针对HTTP无法验证通信方的身份，无法验证报文的完整性以及容易被窃听等安全方面的缺点，HTTPS添加了加密和认证机制，使得HTTP通信更加安全。* HTTPS通信原理（加密机制，不包括认证机制以及验证报文完整性机制，可参考这里） 1.客户端发送请求 2.服务端接收请求返回数字证书 3.客户端使用内置的CA解密证书，拿到公钥 4.如果证书没有问题，就将自己的对称秘钥使用公钥加密发送给服务端 5.服务端使用私钥进行解密 6.客户端和服务端使用对称秘钥进行通信 10、webScoket是什么？主要作用是什么？ 答：webScoket也是一种协议，用来解决要实现实时更新时，只能通过AJAX轮询等方式的问题。使用这个协议就改变了只能客户端发送请求，服务端接收请求的模式，在该协议中客户端和服务端都可以发送请求和接收请求，从而实现实时推送（服务端有数据更新后就发送数据）的功能，基于该协议可以大大的减少通信量。11、SSL有几次握手？具体过程是怎样的？答：这个问题和HTTPS的实现原理可以看做是一样的，但是比较有针对性，以下是回答： SSL有4次握手，握手过程为： 1.客户端请求SSL连接 2.服务端发送包含公钥的证书 3.客户端使用公钥加密对称秘钥并发送给服务端 4.服务端使用私钥解密对称秘钥 文章来源：https://segmentfault.com/a/1190000017322866]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO1！]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80No1%2F</url>
    <content type="text"><![CDATA[前端基础面试题总结1、HTML5新特性HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 2、关于SEO性能优化（1） 减少http请求次数：CSS Sprites， JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的浏览器中 3、怎样理解语义化html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？ 跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 （1）script标签jsonp跨域； （2）nginx反向代理； （3）node.js中间代理跨域； （4）后端在头部信息设置安全域名； （5）后端在服务器上设置cors。 jsonp跨域原理：首先在客户端注册一个callback，然后把callback的名字传给服务器，服务器生成json数据，然后以JavaScript语法生成一个function，function名字就是传递上来的参数jsonp，最后将json数据直接以参数方式放置到function中，生成js文档，返回给客户端，客户端浏览器解析script标签，并执行返回的JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数里（动态执行回调函数） cors跨域需要设置头部Access-Control-Allow-Origin 参数 5、谈一谈对this的理解通常情况下，this指向的是执行上下文中当前的对象；在事件函数中，this通常指向的是事件源DOM元素对象；在构造函数中，this通常指向其new所创建的对象本身。 如何绑定this 可以使用call（）、apply（）绑定使用Function.prototype.bind()进行绑定使用new关键字进行绑定 6、call（）、apply（）、bind（）区别apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为：fun.call(thisArg[, arg1[, arg2[, …]]])apply的语法为：fun.apply(thisArg, [argsArray]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用 7、CSS3新增这里可以分为边框、背景，渐变，阴影、2D转换 3D转换等之类的来说。比如：边框(border-radius、border-shadow、border-image)之类的 8、vue数据双向绑定利用object.defineproperty()这个方法重新定义了对象获取属性值（get）和设置属性值（set）的操作来实现的。 9、前端路由通常 SPA 中前端路由有2种实现方式：window.historylocation.hash 10、let const var有什么区别？let是块级作用域，函数内部使用let定义后，对函数外部无影响。 const定义的变量不可以修改，而且必须初始化。const b = 2;//正确 // const b;//错误，必须初始化 console.log(‘函数外const定义b：’ + b);//有输出值 // b = 5;5 // console.log(‘函数外修改const定义b：’ + b);//无法输出 var定义的变量可以修改，如果不初始化会输出undefined，不会报错。 文章来源：https://juejin.im/post/5ac87838f265da237314b389]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS一些面试题]]></title>
    <url>%2F2019%2F04%2F06%2FJS%20%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、数组模块：1、找出元素 item 在给定数组 arr 中的位置如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1 示例1 输入 [ 1, 2, 3, 4 ], 3 输出 2 function indexOf(arr, item) &#123; return arr.indexOf(item);&#125; 2、数组求和计算给定数组 arr 中所有元素的总和：数组中的元素均为 Number 类型 input [ 1, 2, 3, 4 ] output 10 不考虑算法复杂度，用递归做：function sum(arr) &#123; var len = arr.length; if(len == 0)&#123; return 0; &#125; else if (len == 1)&#123; return arr[0]; &#125; else &#123; return arr[0] + sum(arr.slice(1)); &#125;&#125;常规循环：function sum(arr) &#123; var s = 0; for (var i=arr.length-1; i&gt;=0; i--) &#123; s += arr[i]; &#125; return s;&#125;函数式编程 map-reduce：function sum(arr) &#123; return arr.reduce(function(prev, curr, idx, arr)&#123; return prev + curr; &#125;);&#125;forEach遍历：function sum(arr) &#123; var s = 0; arr.forEach(function(e) &#123; s += e; &#125;) return s;&#125;;eval：function sum(arr) &#123; return eval(arr.join("+"));&#125;; 3、移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4, 2], 2 输出 [1, 3, 4] function remove(arr, item) &#123; //声明一个新数组保存结果 var a = []; //循环遍历 for(var i=0; i &lt; arr.length; i++)&#123; //如果arr[i]不等于item，就加入数组a if(arr[i] != item)&#123; a.push(arr[i]); &#125; &#125; return a; &#125; 移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 输入 [1, 2, 2, 3, 4, 2, 2], 2 输出 [1, 3, 4] function removeWithoutCopy(arr, item) &#123; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i] == item)&#123; arr.splice(i,1);//从数组的第i个位置开始，删除后一个元素 i--;//因为他是直接删除的，那个下标会改变的,所以要自减 &#125; &#125; return arr&#125; removeWithoutCopy([1, 2, 2, 4, 2, 2], 2);1.splice()function remove(arr,item)&#123; for(var i=0;i&lt;newarr.length;i++)&#123; if(newarr[i] == item)&#123; newarr.splice(i,1)； &#125; &#125; return newarr;&#125; 2.push()function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] != item)&#123; newarr.push(arr[i]); &#125; &#125; return newarr;&#125;function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] == item)continue; newarr.push(arr[i]); &#125; return nawarr;&#125;3.Arra y.prototype.filter()function remove(arr,item)&#123; return arr.filter(function(ele)&#123; return ele != item; &#125;)&#125; 4、 添加元素在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4, 10] function append(arr, item) &#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; a.push(arr[i]); &#125; a.push(item); return a;&#125;append([1, 2, 3, 4], 10); 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], ‘z’, 2 输出 [1, 2, ‘z’, 3, 4] //利用slice+concatfunction insert(arr, item, index) &#123; return arr.slice(0,index).concat(item,arr.slice(index));&#125;//利用concat +splicefunction insert(arr, item, index) &#123; var newArr=arr.concat(); newArr.splice(index,0,item); return newArr;&#125;//利用slice+splicefunction insert(arr, item, index) &#123; var newArr=arr.slice(0); newArr.splice(index,0,item); return newArr;&#125;//利用push.apply+splicefunction insert(arr, item, index) &#123; var newArr=[]; [].push.apply(newArr, arr); newArr.splice(index,0,item); return newArr;&#125;//普通的迭代拷贝function insert(arr, item, index) &#123; var newArr=[]; for(var i=0;i&lt;arr.length;i++)&#123; newArr.push(arr[i]); &#125; newArr.splice(index,0,item); return newArr;&#125; 5、删除数组最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 2, 3] function truncate(arr) &#123; var newArr=arr.slice(0)//slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。//语法 stringObject.slice(start,end) newArr.pop()//pop() 方法用于删除并返回数组的最后一个元素。 return newArr&#125; 6.删除数组第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [2, 3, 4] function curtail(arr) &#123; var a = arr.slice(0) a.shift() return a&#125; 7、数组合并合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1] 输出 [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1] //利用concatfunction concat(arr1, arr2) &#123; return arr1.concat(arr2);&#125;//利用slice+push.applyfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); [].push.apply(newArr, arr2); return newArr;&#125;//利用slice+pushfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); for(var i=0;i&lt;arr2.length;i++)&#123; newArr.push(arr2[i]); &#125; return newArr;&#125;//普通的迭代拷贝function concat(arr1, arr2) &#123; var newArr=[]; for(var i=0;i&lt;arr1.length;i++)&#123; newArr.push(arr1[i]); &#125; for(var j=0;j&lt;arr2.length;j++)&#123; newArr.push(arr2[j]); &#125; return newArr;&#125; 8、计数统计数组 arr 中值等于 item 的元素出现的次数 输入 [1, 2, 4, 4, 3, 4, 3], 4 输出 3 //filter()--&gt;利用指定的函数确定是否在返回的数组中包含某一项 function count(arr, item) &#123; var count = arr.filter(function(a) &#123; return a === item; //返回true的项组成的数组 &#125;); return count.length; &#125; //map()--&gt;对数组中的每一项进行给定函数， //返回每次函数条用的结果组成的数组； function count(arr, item) &#123; var count = 0; arr.map(function(a) &#123; if(a === item) &#123; count++; &#125; &#125;); return count; &#125; //for循环 function count(arr, item) &#123; var count = 0; for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] === item) &#123; count++; &#125; &#125; return count; &#125; //reduce()--&gt;从数组的第一项开始，逐个遍历到最后； function count(arr, item) &#123; var count = arr.reduce(function(prev, curr) &#123; return curr === item ? prev+1 : prev; &#125;, 0); return count; &#125; //forEach()--&gt;对数组中的每一项运行传入的函数 function count(arr, item) &#123; var count = 0; arr.forEach(function(a) &#123; a === item ? count++ : 0; &#125;); return count; &#125; 9、查找重复元素找出数组 arr 中重复出现过的元素 输入 [1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 [1, 3, 4] function duplicates(arr) &#123; var a=arr.sort(),b=[]; for(var i in a)&#123; if(a[i]==a[i-1] &amp;&amp; b.indexOf(a[i])==-1) b.push(a[i]); &#125; return b;&#125;//先排序，如果后一个与前一个相等且未保存，则保存。 10、 求二次方为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 4, 9, 16] // 1function square(arr) &#123; var a = arr.slice(0) a = a.map(function(val) &#123; return val*val &#125;) return a&#125;function square(arr) &#123; var newarr = arr.slice(0); //复制一个arr数组 for (var i=0;i&lt;newarr.length;i++)&#123; newarr[i]= newarr[i]* newarr[i]; &#125; return newarr;&#125;// 2function square(arr) &#123; return arr.map(function(item,index,array)&#123; return item*item; &#125;)&#125;//3function square(arr) &#123; //声明一个新的数组存放结果 var a = []; arr.forEach(function(e)&#123; //将arr中的每一个元素求平方后，加入到a数组中 a.push(e*e); &#125;); return a; &#125; 11、查找元素位置在数组 arr 中，查找值与 item 相等的元素出现的所有位置 输入 ‘abcdefabc’ 输出 [0, 6] //filterfunction findAllOccurrences(arr, target) &#123; var result=[]; arr.filter(function(item,index)&#123; return item===target&amp;&amp;result.push(index); &#125;); return result;&#125;//forfunction findAllOccurrences(arr, target) &#123; var result=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===target)&#123; result.push(i); &#125; &#125; return result;&#125;//lastIndexOf+slice/splicefunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.lastIndexOf(target); while(index&gt;-1)&#123; result.push(index); arr.splice(index,1);//arr=arr.slice(0,index); index=arr.lastIndexOf(target); &#125; return result;&#125;//indexOffunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.indexOf(target); while(index&gt;-1)&#123; result.push(index); index=arr.indexOf(target,index+1); &#125; return result;&#125; 二、函数部分 ：1、避免全局变量function globals() &#123; var myObject = &#123; //这里需要加 var let等关键字 name : 'Jory' &#125;; return myObject;&#125; 2、正确的定义函数请修复给定的 js 代码中，函数定义存在的问题 输入 true 输出 a //源码function functions(flag) &#123; if (flag) &#123; function getValue() &#123; return 'a'; &#125; &#125; else &#123; function getValue() &#123; return 'b'; &#125; &#125; return getValue();&#125;// 改正后的function functions(flag) &#123; if (flag) &#123; var getValue =function() &#123; return 'a'; &#125; &#125; else &#123; var getValue =function() &#123; return 'b'; &#125; &#125; return getValue();&#125;functions(true); 3、判断两个数是否相等判断 val1 和 val2 是否完全等同 function identity(val1, val2) &#123; if(val1===val2) &#123; return true; &#125;else&#123; return false &#125;&#125;// 以后就简写装逼function identity(val1, val2) &#123; if(val1===val2)return true; else return false;&#125;/* 一般使用双等来判断（==），如果还需要类型相同那么就用三等（===）。说一下这两个的区别：== equality 等同，=== identity 恒等。==， 两边值类型不同的时候，要先进行类型转换，再比较。 ==，不做类型转换，类型不同的一定不等。 下面分别说明： 先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就[不相等] 2、如果两个都是数值，并且是同一个值，那么[相等]。3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 4、如果两个值都是true，或者都是false，那么[相等]。 5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 6、如果两个值都是null，或者都是undefined，那么[相等]。 再说 ==，根据以下规则： 1、如果两个值类型相同，进行 === 比较。 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么[相等]。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 d、任何其他组合，都[不相等]。*/ 4、计时器实现一个打点计时器，要求1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 function count(start, end) &#123; //立即输出第一个值 console.log(start++); var timer = setInterval(function()&#123; if(start &lt;= end)&#123; console.log(start++); &#125;else&#123; clearInterval(timer); &#125; &#125;,100); //返回一个对象 return &#123; cancel : function()&#123; clearInterval(timer); &#125; &#125;; &#125; 5、流程控制实现 fizzBuzz 函数，参数 num 与返回值的关系如下：1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz2、如果 num 能被 3 整除，返回字符串 fizz3、如果 num 能被 5 整除，返回字符串 buzz4、如果参数为空或者不是 Number 类型，返回 false5、其余情况，返回参数 num 输入: 15 输出： fizzbuzz function fizzBuzz(num) &#123; if(num%3 == 0 &amp;&amp; num%5 == 0) return "fizzbuzz"; else if(num%3 == 0) return "fizz"; else if(num%5 == 0) return "buzz"; else if(num == null || typeof num != "number") return false; else return num;&#125;//又一方法function fizzBuzz(num) &#123; var a = num % 3; var b = num % 5; if (a == 0 &amp;&amp; b == 0) &#123; return 'fizzbuzz'; &#125; else if (a == 0) &#123; return 'fizz' &#125; else if (b == 0) &#123; return 'buzz' &#125; else if (num == 'null' || typeof (num) != 'number') &#123; return false &#125; else &#123; return num &#125;&#125; 6、 函数传参将数组 arr 中的元素作为调用函数 fn 的参数 输入：function (greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }, [‘Hello’, ‘Ellie’, ‘!’] 输出：Hello, Ellie! //调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。function argsAsArray(fn, arr) &#123; return fn.apply(this, arr)&#125;// 调用函数的三种方式obj.func();func.call(obj,args);//参数列出func.apply(obj,[m,n......]);//参数数组 7、函数的上下文将函数 fn 的执行上下文改为 obj 对象 输入：function () {return this.greeting + ‘, ‘ + this.name + ‘!!!’;}, {greeting: ‘Hello’, name: ‘Rebecca’} 输出：Hello, Rebecca!!! //在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function speak(fn, obj) &#123; return fn.apply(obj, obj); &#125; 8、返回函数实现函数 functionFunction，调用之后满足如下条件：1、返回值为一个函数 f2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘3、所有函数的参数数量为 1，且均为 String 类型 输入：functionFunction(‘Hello’)(‘world’) 输出：Hello, world //首先执行functionFunction('Hello')，传入参数str，然后返回函数f，f与('world')组合，执行f('world')，传入参数s，f返回str+", "+s，即Hello, world。注意中间的逗号后面有一个空格。function functionFunction(str) &#123; var f = function(s)&#123; return str+", "+s; &#125; return f; &#125; 9、使用闭包实现函数 makeClosures，调用之后满足如下条件：1、返回一个函数数组 result，长度与 arr 相同2、运行 result 中第 i 个函数，即 resulti，结果与 fn(arr[i]) 相同 输入：[1, 2, 3], function (x) {​ return x * x;} 输出：4 function makeClosures(arr, fn) &#123; var result = []; arr.forEach(function (obj) &#123; result.push(function () &#123; return fn(obj); &#125;) &#125;); return result;&#125;//es6的function makeClosures(arr, fn) &#123; var result = new Array(); for(let i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); //let声明的变量只在let所在代码块内有效，因此每次循环的i都是一个新的变量 &#125;; &#125; return result;&#125;//es5的//这种是错误的写法会导致result中每个函数的参数都是arr[arr.length]function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); &#125;; &#125; return result;&#125;//参考《JavaScript高级程序设计》的典型方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function(num)&#123; return function()&#123; return fn(num); &#125; &#125;(arr[i]); &#125; return result;&#125;//使用ES5的bind()方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = fn.bind(null,arr[i]); &#125; return result;&#125;//使用forEach()function makeClosures(arr, fn) &#123; var result = new Array(); arr.forEach(function(curr)&#123; result.push(function()&#123;return fn(curr)&#125;); &#125;) return result;&#125; 10、二次封装函数已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：1、返回一个函数 result，该函数接受一个参数2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致 输入：var sayIt = function(greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }; partial(sayIt, ‘Hello’, ‘Ellie’)(‘!!!’); 输出：Hello, Ellie!!! // call和apply必须显式地调用str3，立即执行// bind不是立即执行，未传入str3时，并未执行，只是返回一个函数，等待参数传入// this用于上下文不确定的情况 // callfunction partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.call(this, str1, str2, str3); &#125; return result;&#125; // apply（这里只是为了对照）function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.apply(this, [str1, str2, str3]); &#125; return result;&#125; // 这个bind会生成一个新函数（对象）, 它的str1, str2参数都定死了, str3未传入, 一旦传入就会执行function partial(fn, str1, str2) &#123; return fn.bind(this, str1, str2); // 或 return fn.bind(null, str1, str2);&#125; // bind同上, 多了一步, 把str3传入的过程写在另一个函数里面,// 而另一个函数也有str1, str2参数// 此法有种多次一举的感觉，但是表示出了后续的调用。function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.bind(this, str1, str2)(str3); &#125; return result;&#125; // 匿名函数，默认this绑定global，与bind的第一个参数为this时效果一样。function partial(fn, str1, str2) &#123; return function(str3) &#123; return fn(str1, str2, str3); &#125;&#125; // ES6。this指向undefined.const partial = (fn, str1, str2) =&gt; str3 =&gt; fn(str1, str2, str3); 实现函数 partialUsingArguments，调用之后满足如下条件：1、返回一个函数 result2、调用 result 之后，返回的结果与调用函数 fn 的结果一致3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数 输入：无 输出：无 // ****类似与11题*****//arguments不能用slice方法直接截取，需要先转换为数组，var args = Array.prototype.slice.call(arguments);合并参数可以使用concat方法，并且也需要将arguments先转换为数组才能使用concat进行合并。最用使用apply执行传入的函数即可。function partialUsingArguments(fn) &#123; //先获取p函数第一个参数之后的全部参数 var args = Array.prototype.slice.call(arguments,1); //声明result函数 var result = function()&#123; //使用concat合并两个或多个数组中的元素 return fn.apply(null, args.concat([].slice.call(arguments))); &#125; return result; &#125; 11、使用arguments函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。 输入：1, 2, 3, 4 输出：10 function useArguments() &#123; /* 因为参数数量不定，可以先获取参数个数arguments.length 然后循环求值 */ //声明一个变量保存最终结果 var sum = 0; //循环求值 for(var i = 0; i &lt; arguments.length; i++)&#123; sum += arguments[i]; &#125; return sum; &#125;console.log(useArguments(1,2,3,4));//output 10 12、使用apply 调用函数实现函数 callIt，调用之后满足如下条件1、返回的结果为调用 fn 之后的结果2、fn 的调用参数为 callIt 的第一个参数之后的全部参数 输入：无 输出：无 //因为arguments并非真正的数组，因此要获得callIt的第一个参数之后的所有参数，不能直接使用slice方法截取，需要先将arguments转换为真正的数组才行。有两种常见的方法，一是使用slice方法：var args = Array . prototype . slice . call ( arguments );二是循环遍历逐一填入新数组。在获得了args之后，就可以调用apply来执行传入的函数参数。function callIt(fn) &#123; //将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); //调用fn var result = fn.apply(null,args);//因为调用calllt的第一个参数之后的全部参数，所以这里是null return result;&#125; 13、柯里化柯里化有3个常见作用： 1. 参数复用 ；2. 提前返回；3. 延迟计算/运行 已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 13、调用 b 之后，返回一个函数 c, c 的 length 属性值为 14、调用 c 之后，返回的结果与调用 fn 的返回值一致5、fn 的参数依次为函数 a, b, c 的调用参数 输入：var fn = function (a, b, c) {return a + b + c}; ​ curryIt(fn)(1)(2)(3); 输出：6 function curryIt(fn) &#123; return a = function(d)&#123; var b1 = arguments[0]; return b = function(f)&#123; var c1 = arguments[0]; return c = function(g)&#123; var a1 = arguments[0]; return fn.call(this,d,f,g); &#125; &#125; &#125;&#125;//柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数。function curryIt(fn) &#123; //获取fn参数的数量 var n = fn.length; //声明一个数组args var args = []; //返回一个匿名函数 return function(arg)&#123; //将curryIt后面括号中的参数放入数组 args.push(arg); //如果args中的参数个数小于fn函数的参数个数， //则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。 //否则，返回fn的调用结果 if(args.length &lt; n)&#123; return arguments.callee; &#125;else return fn.apply("",args); &#125; &#125; 三、逻辑运算：1、或运算返回参数 a 和 b 的逻辑或运算结果 输入：false, true 输出：true function or(a, b) &#123; if(a||b) return true; else return false;&#125; 2、且运算返回参数a 和 b 的逻辑且运算结果 输入：false, true 输出： false functino add(a,b)&#123; return a&amp;&amp;b;&#125; 四、其它部分：1、模块完成函数 createModule，调用之后满足如下要求：1、返回一个对象2、对象的 greeting 属性值等于 str1， name 属性值等于 str23、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值 声明对象有两种常见的方式：var obj = &#123;&#125;;和var obj = new Object();。前面一种可以直接在括号中以key:value的方式定义属性，后一种采用点运算符给对象添加属性。function createModule(str1, str2) &#123; var obj = &#123; greeting : str1, name : str2, sayIt : function()&#123; //两个属性前面都需要加上this return this.greeting+", "+this.name; &#125; &#125;; return obj; &#125; console.log(createModule("11","22"))//&#123;greeting: "11", name: "22", sayIt: ƒ&#125; 2、二进制转换获取数字 num 二进制形式第 bit 位的值。注意：1、bit 从 1 开始2、返回 0 或 13、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1 输入：128,8 输出：1 通过num.toString(2)能直接将num转换为2进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。function valueAtBit(num, bit) &#123; var s = num.toString(2); console.log(s);//1000 0000 console.log(s.length)//8 return s[s.length - bit]; &#125; console.log(valueAtBit(128,8))//1 给定二进制字符串，将其换算成对应的十进制数字 输入：’11000000’ 输出：192 parseInt方法可以将其它进制转换为十进制，只需要给该方法传入需要转换的字符串和该字符串的进制表示两个参数即可。function base10(str) &#123; /** 其它进制转十进制 parseInt(str,2) parseInt(str,8) parseInt(str,16) */ return parseInt(str,2);&#125;console.log(base10('11000000'))//192 将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。 输入：65 输出：01000001 function convertToBinary(num) &#123; var s = num.toString(2); while(s.length&lt;8)&#123; s = '0'+s; &#125; return s;&#125;//首先通过toString方法将num转为2进制数形式，然后判断其长度是否足够8位。如不足8位，则声明一个“0000000”字符串用于补0，因为目标的2进制数形式最少为一位，因此最多只需要7个0；通过slice方法对“0000000”进行截取，然后将其结果加在目标前面即可。function convertToBinary(num) &#123; //转换为2进制格式 var s = num.toString(2); //获得2进制数长度 if( s.length&lt;8)&#123; //声明一个字符串用于补满0 var s1 = "0000000"; var s2 = s1.slice(0,8-l); s = s2+s; &#125; return s; &#125; 3、乘法求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题 输入：3, 0.0001 输出：0.0003 // 1 function multiply(a, b) &#123; return a*b*10000*10000/10000/10000&#125;// 2//根据两个书中精度较高的一个来确定，先将其转换成字符串，然后根据小数点的位置确定小数位数，//字符串长度减去‘.'的位置后还要再减去1得到正确的小数位数，两个取其大，然后用toFixed()函数确定 //结果的小数位数function multiply(a, b) &#123; //求两个数中精度大的一个 var stra=a.toString(); var strb=b.toString(); var len=Math.max(stra.length-stra.indexOf('.')-1,strb.length-strb.indexOf('.')-1); // return parseFloat(a*b).toFixed(len);&#125;// 3//通过将a、b小数位数的相加，能够得到a*b结果的小数位数最大可能值。然后使用toFixed方法可以将结果的小数位数指定为可能的最大值，即保证了结果的精度。但本题实际上，仅返回a*b也能通过。在浏览器上做实验，最大17位的小数位数满足了该题全部的测试用例。function multiply(a, b) &#123; return a*b; &#125; 4、改变上下文将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值 输入：alterContext(function() {return this.greeting + ‘, ‘ + this.name + ‘!’; }, {name: ‘Rebecca’, greeting: ‘Yo’ }) 输出：Yo, Rebecca! //主要有三种答案。function alterContext(fn, obj) &#123; return fn.bind(obj)();//.bind()返回的是一个函数，所以需要立即执行。 &#125; function alterContext(fn, obj) &#123; return fn.call(obj);&#125; function alterContext(fn, obj) &#123; return fn.apply(obj);&#125; //在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function alterContext(fn, obj) &#123; return fn.call(obj,obj); &#125; 5、批量改变对象属性 ( 涉及原型链问题 )给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。 输入：var C = function(name) {this.name = name; return this;};var obj1 = new C(‘Rebecca’);alterObjects(C, ‘What\’s up’); obj1.greeting; 输出：What’s up //这是原型链问题。访问一个对象的方法或者是属性，首先会在该对象中寻找，如果找到则返回，如果没找到，则在其原型链上面向上寻找，直至基原型，如还未找到，则返回undefined。将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量，只需要在constructor的原型上面添加greeting属性，并指定值。function alterObjects(constructor, greeting) &#123; //添加prototype的作用就是添加一个公共方法，或者公共属性 constructor.prototype.greeting = greeting; &#125; 6、属性遍历找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)1、返回数组，格式为 key: value2、结果数组不要求顺序 输入：var C = function() {this.foo = ‘bar’; this.baz = ‘bim’;};C.prototype.bop = ‘bip’;iterate(new C()); 输出：[“foo: bar”, “baz: bim”] //可以使用for-in来遍历对象中的属性，hasOwnproperty方法能返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性，该属性必须为对象本身的属性。function iterate(obj) &#123; var arr = []; //使用for-in遍历对象属性 for(var key in obj)&#123; //判断key是否为对象本身的属性 if(obj.hasOwnProperty(key))&#123; //将属性和值按格式存入数组 arr.push(key+": "+obj[key]); &#125; &#125; return arr; &#125; 7、判断是否包含数字（涉及正则表达式）给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false 输入：’abc123’ 输出：true // 方法一//判断字符串中是否含有数字，可以用正则表达式。/\d/可以匹配字符串中的数字字符，用test方法可以检测。function containsNumber(str) &#123; var b = /\d/; return b.test(str); &#125;//方法二function containsNumber(str) &#123; for(var i=0 ; i&lt;str.length ; i++)&#123; if(str[i] &gt; '0' &amp;&amp; str[i] &lt; '9')&#123; return true; &#125; &#125; return false;&#125; 8、检查重复字符串(正则表达式)给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 输入：’rattler’ 输出：true 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\1就是引用第一个分组，\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。function containsRepeatingLetter(str) return /([a-zA-Z])\1/.test(str); 9、判断是否以元音字母结尾（正则表达式）给定字符串 str，检查其是否以元音字母结尾1、元音字母包括 a，e，i，o，u，以及对应的大写2、包含返回 true，否则返回 false 输入：’gorilla’ 输出：true //首先确定元音集合[a,e,i,o,u]，然后是以元音结尾，加上$，最后通配大小写，加上i。因此正则表达式为:/[a,e,i,o,u]$/i，最后用test方法去检测字符串strfunction endsWithVowel(str) &#123; return /[a,e,i,o,u]$/i.test(str); &#125; 10、获取指定字符串(正则表达式）给定字符串 str，检查其是否包含 连续3个数字1、如果包含，返回最新出现的 3 个数字的字符串2、如果不包含，返回 false 输入：’9876543’ 输出：987 function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false;&#125;//题目描述有问题，实际考察的是字符串中是否含有连续的三个任意数字，而不是三个连续的数字。依题，若存在连续的三个任意数字，则返回最早出现的三个数字，若不存在，则返回false。因此需要用到match方法，match()返回的是正则表达式匹配的字符串数组，连续的三个任意数字用正则表达式表示为/\d&#123;3&#125;/。function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false; &#125; 11、判断是否符合指定格式 (正则表达式）给定字符串 str，检查其是否符合如下格式1、XXX-XXX-XXXX2、其中 X 为 Number 类型 输入：’800-555-1212’ 输出：true //本题需要注意格式，开头^和结尾$必须加上来限定字符串，3个数可表示为\d&#123;3&#125;，4个数则为\d&#123;4&#125;，&#123;n&#125;表示前面内容出现的次数。正则表达式可写作/^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$/，有相同部分\d&#123;3&#125;-，因此也可写作/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/function matchesPattern(str) &#123; return/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 12、判断是否符合 USD 格式 (正则表达式）给定字符串 str，检查其是否符合美元书写格式1、以 $ 开始2、整数部分，从个位起，满 3 个数字用 , 分隔3、如果为小数，则小数部分长度为 24、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3输入：&apos;$20,933,209.93&apos;输出：true //本题注意点有必须是USD格式，以$开头，数字结尾，$和小数点的转义。首先，开头必是$，而正则表达式中$表示结尾，需要进行转义，因此开头为^\$然后$后必然接数字，并且最少一位，最多三位数，可用&#123;m,n&#125;表示,最少m位，最多n位，因此此段为\d&#123;1,3&#125;接着，后面如还有数，则必然有，分隔，并且后面必有3个数，类似于，XXX的格式会出现0或者n次，因此此段可表示为(,\d&#123;3&#125;)*最后，如有小数部分，则注意对小数点进行转义，此段可表示为(\.\d&#123;2&#125;)?因此，最后的正则表达式为/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/使用test方法去检测strfunction isUSD(str) &#123; return /^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/.test(str);&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在window把自己的项目上传到github]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%9C%A8window%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[1.首先简单粗暴的在GitHub上创建自己的库： 2.创建仓库成功后看下图，复制下图这个地址，这是这个仓库的地址，我们项目要传到这里来 3.然后下载git，网上有很多教程（相信自己可以看得懂），安装后运行cd进入到自己的项目目录里（如下图）： 4.然后输入git init，如下图所示，这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹） 第二步： 输入git add . 这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把 . 换成这个特定的文件名即可，记住add和点号中间要有空格。 第三步： 输入git commit -m “first commit”，表示你对这次提交的注释，双引号里面的内容可以根据个人的需要更改。 第四步： 输入git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上， 第五步： 输入git pull –rebase origin master 使得远程库与本地库一致，我们把远程库同步到本地库就可以了 第六步： 输入git push -u origin master，这是把代码上传到github仓库的意思 5.执行完后，如果没有异常，会等待几秒，然后跳出一个让你输入Username和Password 的窗口，你只要输入 github的登录账号和密码就行了。 如果你之前你已经登陆过，那么就跳过上面步骤，直接等待下图就可以了： 这个是上传进度，这个过程可能有点慢，有时候大的项目要得等个10几分钟，之后去检查GitHub的仓库里有没有就可以了。 本次分享来源于自己的实践，参考了文章：https://blog.csdn.net/wu2374633583/article/details/79130984]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网页中标签出现的个数]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%BB%9F%E8%AE%A1%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%A0%87%E7%AD%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[废话不多说直接上代码吧： //获取所有标签 var doms = document.getElementsByTagName("*"); //去重 var obj =&#123;&#125; var ret =[] for(var j =0;j&lt;doms.length;j++)&#123; var name = doms[j].nodeName if(!obj[name])&#123; ret.push(name) obj[name]=true &#125; &#125; console.log(ret.length)]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2019%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to CAN7! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是如何建立这个博客的！]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[本次学习完全依赖于这位不知名大佬的文章： 2018，你该搭建自己的博客了！*https://juejin.im/entry/5a574864f265da3e3c6c1217*]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>git管理</tag>
      </tags>
  </entry>
</search>
