<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解this指向</title>
      <link href="/2020/05/15/%E8%AF%A6%E8%A7%A3this%E6%8C%87%E5%90%91/"/>
      <url>/2020/05/15/%E8%AF%A6%E8%A7%A3this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/5/15/17218b247a078d96?w=693&amp;h=300&amp;f=jpeg&amp;s=10477" alt><br>在 JavaScript 编程中，this 关键字总是让初学者感到迷惑！<br>跟别的语言大相径庭的是，JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在<br>运行时基于<font color="blue" size="4">函数的执行环境动态绑定的，而非函数被声明时的环境</font></p><p> 具体到实际应用中，this 的指向大致可以分为以下 4 种</p><h2 id="1、作为对象的方法调用"><a href="#1、作为对象的方法调用" class="headerlink" title="1、作为对象的方法调用"></a>1、作为对象的方法调用</h2><p>当函数作为对象的方法被调用时，this 指向该对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line"> a: 1, </span><br><span class="line"> getA: function()&#123; </span><br><span class="line">    alert ( this === obj ); // 输出：true </span><br><span class="line">    alert ( this.a ); // 输出: 1 </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure></p><h2 id="2、作为普通函数调用"><a href="#2、作为普通函数调用" class="headerlink" title="2、作为普通函数调用"></a>2、作为普通函数调用</h2><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指<br>向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &apos;globalName&apos;; </span><br><span class="line">var getName = function()&#123; </span><br><span class="line">    return this.name; </span><br><span class="line">&#125;; </span><br><span class="line">console.log( getName() ); // 输出：globalName</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">window.name = &apos;globalName&apos;; </span><br><span class="line">var myObject = &#123; </span><br><span class="line"> name: &apos;sven&apos;, </span><br><span class="line"> getName: function()&#123; </span><br><span class="line"> return this.name; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">var getName = myObject.getName; </span><br><span class="line">console.log( getName() ); // globalName</span><br></pre></td></tr></table></figure><p>有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法，<br>callback 被作为普通函数调用时，callback 内部的 this 指向了 window，但我们往往是想让它指向<br>该 div 节点，见如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">  &lt;body&gt; </span><br><span class="line">     &lt;div id=&quot;div1&quot;&gt;我是一个 div&lt;/div&gt; </span><br><span class="line"> &lt;/body&gt; </span><br><span class="line"> &lt;script&gt; </span><br><span class="line">     window.id = &apos;window&apos;; </span><br><span class="line">     document.getElementById( &apos;div1&apos; ).onclick = function()&#123; </span><br><span class="line">        alert ( this.id ); // 输出：&apos;div1&apos; </span><br><span class="line">        var callback = function()&#123; </span><br><span class="line">          alert ( this.id ); // 输出：&apos;window&apos; </span><br><span class="line">        &#125; </span><br><span class="line">     callback(); </span><br><span class="line">     &#125;; </span><br><span class="line"> &lt;/script&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>此时有一种简单的解决方案，即把把this改为_this：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; </span><br><span class="line">  &lt;body&gt; </span><br><span class="line">     &lt;div id=&quot;div1&quot;&gt;我是一个 div&lt;/div&gt; </span><br><span class="line"> &lt;/body&gt; </span><br><span class="line"> &lt;script&gt; </span><br><span class="line">     window.id = &apos;window&apos;; </span><br><span class="line">     document.getElementById( &apos;div1&apos; ).onclick = function()&#123; </span><br><span class="line">        alert ( this.id ); // 输出：&apos;div1&apos; </span><br><span class="line">        var _this =this</span><br><span class="line">        var callback = function()&#123; </span><br><span class="line">          alert ( _this.id ); // 输出：&apos;window&apos; </span><br><span class="line">        &#125; </span><br><span class="line">     callback(); </span><br><span class="line">     &#125;; </span><br><span class="line"> &lt;/script&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>But,在 ECMAScript 5 的 严格模式（strict ）下，这种情况下的 this 已经被规定为不会指向全局对象，而<br>是 undefined：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func()&#123; </span><br><span class="line">    &quot;use strict&quot; </span><br><span class="line">    alert ( this ); // 输出：undefined </span><br><span class="line">&#125; </span><br><span class="line">func();</span><br></pre></td></tr></table></figure></p><h2 id="3、构造器调用"><a href="#3、构造器调用" class="headerlink" title="3、构造器调用"></a>3、构造器调用</h2><p>JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造<br>器看起来更像一个类。<br>除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用。构造器的外<br>表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总<br>会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var MyClass = function()&#123; </span><br><span class="line"> this.name = &apos;sven&apos;; </span><br><span class="line">&#125;; </span><br><span class="line">var obj = new MyClass(); </span><br><span class="line">alert ( obj.name ); // 输出：sven</span><br></pre></td></tr></table></figure></p><p>但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对<br>象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var MyClass = function()&#123; </span><br><span class="line"> this.name = &apos;sven&apos;; </span><br><span class="line"> return &#123; // 显式地返回一个对象</span><br><span class="line"> name: &apos;anne&apos; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line">var obj = new MyClass(); </span><br><span class="line">alert ( obj.name ); // 输出：anne</span><br></pre></td></tr></table></figure></p><p>如果构造器不显式地返回任何数据，或者是返回一个<strong>非对象类型</strong>的数据，就不会造成上述问题：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var MyClass = function()&#123; </span><br><span class="line">  this.name = &apos;sven&apos; </span><br><span class="line">  return &apos;anne&apos;; // 返回 string 类型</span><br><span class="line">&#125;; </span><br><span class="line">var obj = new MyClass(); </span><br><span class="line">alert ( obj.name ); // 输出：sven</span><br></pre></td></tr></table></figure><h2 id="4、-Function-prototype-call-或-Function-prototype-apply-调用"><a href="#4、-Function-prototype-call-或-Function-prototype-apply-调用" class="headerlink" title="4、 Function.prototype.call 或 Function.prototype.apply 调用"></a>4、 Function.prototype.call 或 Function.prototype.apply 调用</h2><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地<br>改变传入函数的 this：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123; </span><br><span class="line">  name: &apos;sven&apos;, </span><br><span class="line">  getName: function()&#123; </span><br><span class="line">    return this.name; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br><span class="line">var obj2 = &#123; </span><br><span class="line">  name: &apos;anne&apos; </span><br><span class="line">&#125;; </span><br><span class="line">console.log( obj1.getName() ); // 输出: sven </span><br><span class="line">console.log( obj1.getName.call( obj2 ) ); // 输出：anne</span><br></pre></td></tr></table></figure></p><p>call 和 apply 方法能很好地体现 JavaScript 的函数式语言特性，在 JavaScript 中，几乎每一次编写函数式语言风格的代码，都离不开 call 和 apply。在 JavaScript诸多版本的设计模式中，也用到了 call 和 apply。</p><h2 id="注⚠️："><a href="#注⚠️：" class="headerlink" title="注⚠️："></a>注⚠️：</h2><p>除去不常用的 with 和 eval 的情况，具体到实际应用中，this 的指向大致可以分为以上4 种，文章参考于：<font color="red"> JavaScript设计模式与开发实践 第二章 </font></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础知识总结</title>
      <link href="/2020/05/11/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/11/Vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/5/11/17203fabd0d9c9c4?w=1000&amp;h=500&amp;f=png&amp;s=20368" alt></p><p>不可质疑，国内Vue使用者多于React使用者，其中Vue官网有一段这样的表述：“更抽象一点来看，我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件”。所以Vue相比React还是有一定的优势！</p><p>但我写这篇<font color="blue" size="5">“流水文章”</font>,是为了面试也为了系统总结一下Vue相关知识。</p><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h4 id="谈谈你对MVVM的理解"><a href="#谈谈你对MVVM的理解" class="headerlink" title="谈谈你对MVVM的理解"></a>谈谈你对MVVM的理解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MVVM是 Model、View、 ModelView的缩写 </span><br><span class="line"></span><br><span class="line">Model: 数据模型层，可以在Model中定义数据修改和操作的业务逻辑</span><br><span class="line">View:  数据视图层，将数据模型转为UI展现出来</span><br><span class="line">Model-View:  监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。</span><br></pre></td></tr></table></figure><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><p>然后再来看一下的图示：<br><img src="https://user-gold-cdn.xitu.io/2020/5/11/17203fa27b85ba0f?w=556&amp;h=423&amp;f=png&amp;s=11245" alt><br>它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><h4 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h4><p>beforeCreate（创建前） 组件实例被创建之初，组件的属性生效之前</p><p>created （创建后）  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，<code>$el</code> 还不可用始，<code>$el</code>还没有显示出来</p><p>beforeMount (挂载前)  在挂载开始之前被调用：相关的 render 函数首次被调用</p><p>mounted （挂载后） el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</p><p>beforeUpdate （更新前）组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</p><p>update （更新后） 组件数据更新之后</p><p>beforeDestroy （销毁前） 组件销毁前调用</p><p>destroyed （销毁后） 组件销毁后调用</p><p>盗一张图：<font color="blue" size="4">生命周期示意图</font></p><p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca74f183827f46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><ul><li><p>什么是vue生命周期以及作用</p><p> 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p><p>作用：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br><br></p></li><li><p>第一次页面加载会触发哪几个钩子？</p><p>答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。<br><br></p></li><li>DOM 渲染在 哪个周期中就已经完成？<br>答：DOM 渲染在 mounted 中就已经完成了。</li></ul><h4 id="vue路由的钩子函数"><a href="#vue路由的钩子函数" class="headerlink" title="vue路由的钩子函数"></a>vue路由的钩子函数</h4><p><strong>全局守卫：</strong><br>   router.beforeEach 全局前置守卫 进入路由之前<br>   router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用<br>   router.afterEach 全局后置钩子 进入路由之后</p><ul><li>使用方法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.js 入口文件</span><br><span class="line">import router from &apos;./router&apos;; // 引入路由</span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  console.log(&apos;afterEach 全局后置钩子&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>关于to from next 这三个参数</p><ul><li><p>to：route即将进入的目标路由对象</p></li><li><p>from：route当前导航正要离开的路由</p></li><li><p>next：function一定要调用该方法resolve这个钩子。执行效果依-赖next方法的调用参数。可以控制网页的跳转。</p></li></ul></li></ul><p><strong>组件内守卫：</strong></p><p>beforeRouteEnter 进入路由前<br>beforeRouteUpdate (2.2) 路由复用同一个组件时<br>beforeRouteLeave 离开当前路由时</p><p>这一部分自己不是很清楚，没必要强行写下去了，参考来自于：</p><p><a href="https://juejin.im/post/5b41bdef6fb9a04fe63765f1#heading-4" target="_blank" rel="noopener">Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]</a></p><h4 id="Vue的路由实现-hash模式-和-history模式"><a href="#Vue的路由实现-hash模式-和-history模式" class="headerlink" title="Vue的路由实现: hash模式 和 history模式"></a>Vue的路由实现: hash模式 和 history模式</h4><ul><li>hash模式<ul><li>浏览器url中带“#”号</li><li>用window.location.hash读取</li><li>不需要server端支持</li></ul></li><li>history模式<ul><li>采用HTML5的新特性</li><li>且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</li><li>需要server端支持</li></ul></li></ul><h4 id="说一下你对Vuex的理解"><a href="#说一下你对Vuex的理解" class="headerlink" title="说一下你对Vuex的理解"></a>说一下你对Vuex的理解</h4><ul><li><p><strong>是干什么的</strong></p><p>Vuex 是专门为 Vue.js 设计的状态管理库，它采用集中式存储管理应用的所有组件的状态。<br>But，为什么需要状态管理：很多人最初喜欢用 Vue，React 这类框架，大概都是因为框架的响应式特性——当数据改变时，视图会进行重新渲染。这其实正是框架解决的最核心的问题。<br>然而，对于简单的状态管理，一个简单的 store 模式就足够了，那么复杂的状态管理呢，所以，Vuex出现。</p></li><li><p><strong>使用场景</strong></p><ul><li>多个视图使用于同一状态</li></ul><p>传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力</p><ul><li>不同视图需要变更同一状态：</li></ul><p>采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝，通常会导致无法维护的代码</p></li></ul><p><br></p><ul><li><strong>Vuex图示</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/11/17203fa2d48a2ba5?w=701&amp;h=551&amp;f=png&amp;s=8112" alt></p><p>流程简化：<br>View components -&gt; actions(dispatch方式) -&gt; mutations(commit方式) -&gt; state -&gt; View components, 而 getters则可以理解为computed，作为state的计算属性</p><ul><li>state<ul><li>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li></ul></li><li>mutations<ul><li>mutations定义的方法动态修改Vuex 的 store 中的状态或数据（必须是同步的）</li></ul></li><li>getters<ul><li>类似vue的计算属性，主要用来过滤一些数据。</li></ul></li><li>action<ul><li>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li></ul></li></ul><h4 id="谈谈你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#谈谈你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="谈谈你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>谈谈你对 SPA 单页面的理解，它的优缺点分别是什么？</h4><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；<br>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h4 id="此部分，待更新❤️"><a href="#此部分，待更新❤️" class="headerlink" title="此部分，待更新❤️"></a>此部分，待更新❤️</h4><p>所以，频繁切换要用v-show，不频繁切换要用v-if，为了性能的提升</p><h2 id="一些面试题"><a href="#一些面试题" class="headerlink" title="一些面试题"></a>一些面试题</h2><h4 id="v-show-与-v-if-有什么区别？"><a href="#v-show-与-v-if-有什么区别？" class="headerlink" title="v-show 与 v-if 有什么区别？"></a>v-show 与 v-if 有什么区别？</h4><ul><li><p>区别</p><ul><li>v-show会渲染dom树，用style=display:none隐藏</li><li>v-if  不会渲染dom树</li></ul></li><li><p>结论</p><ul><li>So，频繁切换要用v-show，不频繁切换要用v-if，为了性能的提升</li></ul></li></ul><h4 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h4><ul><li>computed 有缓存，data不变它也不变</li><li>watch 默认是浅监听，watch对于引用类型必须深度监听（要加属性条件）deep:  true</li></ul><h4 id="vue为什么不能检测数组的变化"><a href="#vue为什么不能检测数组的变化" class="headerlink" title="vue为什么不能检测数组的变化"></a>vue为什么不能检测数组的变化</h4><p>Vue2.0对于响应式数据的实现有一些不足：</p><ul><li>无法检测数组/对象的新增</li><li>无法检测通过索引改变数组的操作</li></ul><p>解决：</p><ul><li>Vue.set()方法 //针对第一个问题</li><li>Vue3.0采用Proxy替代了Object.definePropert 因为Object.DefineProperty的缺点，vue3 启用proxy</li></ul><p>那么Object.definePropert的缺点是：<br><br><br>1、深度监听，需要一次性递归到底，一次性计算量大<br><br>2、新增和删除属性监听不到，需要Vue.set() 和 Vue.delete()<br><br>3、无法原生监听数组，需要特殊处理</p><h4 id="v-for的key值问题"><a href="#v-for的key值问题" class="headerlink" title="v-for的key值问题"></a>v-for的key值问题</h4><p>一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果</p><h4 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h4><p>参考资料：</p><p><a href="https://juejin.im/post/5d59f2a451882549be53b170#heading-28" target="_blank" rel="noopener">你有对 Vue 项目进行哪些优化？</a></p><p><strong>（1）代码层面的优化</strong></p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><p><strong>（2）Webpack 层面的优化</strong></p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><p><strong>（3）基础的 Web 技术的优化</strong></p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="待更新❤️"><a href="#待更新❤️" class="headerlink" title="待更新❤️"></a>待更新❤️</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue高级特性</title>
      <link href="/2020/05/10/Vue%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2020/05/10/Vue%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Vue为我们提供了很多高级特性，学习和掌握它们有助于提高我们的代码水平，本次小结来源于慕课网实战视频，网上搜索了一下，发先已经有同学写好了总结，那我就<font color="blue">借花献佛：</font></p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p><a href="https://juejin.im/post/5eaa39f7f265da7b983b9f05" target="_blank" rel="noopener">前端进阶必会的六个Vue高级特性</a></p><p>除此之外，小小补充一下：</p><h2 id="watch进阶"><a href="#watch进阶" class="headerlink" title="watch进阶"></a>watch进阶</h2><p>从我们刚开始学习Vue的时候，对于侦听属性，都是简单地如下面一般使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">watch:&#123;</span><br><span class="line">a()&#123;</span><br><span class="line"> //doSomething</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，Vue对watch提供了很多进阶用法。</p><h4 id="handler函数"><a href="#handler函数" class="headerlink" title="handler函数"></a>handler函数</h4><p>以对象和handler函数的方式来定义一个监听属性，handler就是处理监听变动时的函数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">a:&#123;</span><br><span class="line">handler:&apos;doSomething&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">doSomething()&#123;</span><br><span class="line">//当 a 发生变化的时候，做些处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handler有啥用？是多此一举么？用途主要有两点：</p><ul><li>将处理逻辑抽象出去了，以method的方式被复用</li><li>给定义下面两个重要属性留出了编写位置</li></ul><h4 id="deep属性"><a href="#deep属性" class="headerlink" title="deep属性"></a>deep属性</h4><p>不知道你注意到了没有？</p><p>当watch的是一个Object类型的数据，如果这个对象内部的某个值发生了改变，并不会触发watch动作！</p><p>也就是说，watch默认是浅监听，watch对于值类型可以监听，但是引用类型必须深度监听（要加属性条件）deep:  true</p><p>为解决这一问题，就要使用deep属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">obj:&#123;</span><br><span class="line">handler:&apos;doSomething&apos;,</span><br><span class="line">deep:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">doSomething()&#123;</span><br><span class="line">//当 obj 发生变化的时候，做些处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>deep属性默认为false，也就是我们常用的watch模式。</p><h2 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h2><p>我们知道，在单文件组件的style中使用 scoped 属性后，父组件的样式将不会渗透到子组件中。</p><p>不过一个子组件的根节点会同时受其父组件的 scoped CSS 和子组件的 scoped CSS 的影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。</p><p>如果你希望父组件的 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用深度选择器： &gt;&gt;&gt; 操作符。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>上述代码将会编译成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.a[data-v-f3f3eg9] .b &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure></p><p>但是，有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符，这两者都是 &gt;&gt;&gt; 的别名，实现同样的功能。</p><p>我们都知道，通过 v-html 创建的 DOM 内容不受 scoped 样式影响，可以通过深度作用选择器&gt;&gt;&gt;来为他们设置样式。</p><h2 id="吧啦吧啦，继续更新❤️"><a href="#吧啦吧啦，继续更新❤️" class="headerlink" title="吧啦吧啦，继续更新❤️"></a>吧啦吧啦，继续更新❤️</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> watch </tag>
            
            <tag> scoped </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS伪类和伪元素</title>
      <link href="/2020/05/08/CSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>/2020/05/08/CSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>先说一说为什么 css 要引入伪元素和伪类，以下是<a href="https://www.w3.org/TR/CSS2/selector.html#pseudo-elements" target="_blank" rel="noopener">css2.1 Selectors 章节中对伪类与伪元素的描述：</a></p><p>CSS introduces the concepts of pseudo-elements and pseudo-classes  to permit formatting based on information that lies outside the document tree.</p><p>直译过来就是：css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。下面分别对伪类和伪元素进行解释：</p><p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover 来描述这个元素的状态。虽然它和普通的 css 类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><h2 id="伪类与伪元素的区别VS"><a href="#伪类与伪元素的区别VS" class="headerlink" title="伪类与伪元素的区别VS"></a>伪类与伪元素的区别VS</h2><p>可以这么理解： </p><ul><li>它们是否创造了新的元素(抽象)。从我们模仿其意义的角度来看，如果需要添加新元素加以标识的，就是<strong>伪元素</strong>，反之，如果只需要在既有元素上添加类别的，就是<strong>伪类</strong>。</li><li>伪元素在一个选择器里只能出现一次，并且只能出现在末尾;<br>伪类则是像真正的类一样发挥着类的作用，没有数量上的限制，只要不是相互排斥的伪类，也可以同时使用在相同的元素上。</li></ul><h2 id="常用伪类与伪元素"><a href="#常用伪类与伪元素" class="headerlink" title="常用伪类与伪元素"></a>常用伪类与伪元素</h2> <font color="#0099ff" size="3" face="黑体">常用伪类 </font><h4 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:link 选择未访问的链接</span><br><span class="line"></span><br><span class="line">:visited  选择已访问的链接</span><br><span class="line"></span><br><span class="line">:hover  选择鼠标指针浮动在其上的元素</span><br><span class="line"></span><br><span class="line">:active  选择活动的链接</span><br><span class="line"></span><br><span class="line">:focus   选择获取焦点的输入字段</span><br></pre></td></tr></table></figure><h4 id="结构化："><a href="#结构化：" class="headerlink" title="结构化："></a>结构化：</h4><ul><li><p>:not    一个否定伪类，用于匹配不符合参数选择器的元素</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li class=&quot;first-item&quot;&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  </span><br><span class="line">  li:not(.first-item) &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>:first-child  匹配元素的第一个子元素</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如下例，第一个&lt;li&gt; 元素的文本会变为橙色。</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这里的文本是橙色的&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">li:first-child &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>:last-child  匹配元素的最后一个子元素</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 如下例，最后一个&lt;li&gt; 元素的文本会变为橙色</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这里的文本是橙色的&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">li:last-child &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>:first-of-type 匹配属于其父元素的首个特定类型的子元素的每个元素<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如下例，第一个&lt;li&gt; 元素和第一个&lt;span&gt; 元素的文本会变为橙色</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;这里的文本是橙色的&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本 &lt;span&gt;这里的文本是橙色的&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ul :first-of-type &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>:last-of-type  匹配元素的最后一个子元素。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如下例，最后一个&lt;li&gt; 元素的文本会变为橙色</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;span&gt;一些文本&lt;/span&gt; &lt;span&gt;这里的文本是橙色的&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;一些文本&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;这里的文本是橙色的&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">ul :last-of-type &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h4><ul><li>:checked 匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如下例，当复选框被选中时，与其相邻的&lt;label&gt; 元素的背景会变成黄色</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;checkbox&quot;/&gt;</span><br><span class="line">&lt;label&gt;我同意&lt;/label&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input:checked + label &#123;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:default 匹配默认选中的元素，例如：提交按钮总是表单的默认按钮。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如下例，只有提交按钮的背景变成了黄色</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;#&quot;&gt;</span><br><span class="line">    &lt;button&gt;重置&lt;/button&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">:default  &#123;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:disabled 匹配禁用的表单元素</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如下例，被禁用 input 输入框的透明度会变成 50%。</span><br><span class="line">&lt;input type=&quot;text&quot; disabled/&gt;</span><br><span class="line"></span><br><span class="line">:disabled &#123;</span><br><span class="line">    opacity: .5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:empty 匹配没有子元素的元素。如果元素中含有文本节点、HTML 元素或者一个空格，则:empty 不能匹配这个元素。</li></ul><p>如下例，:empty 能匹配的元素会变为黄色。</p><p>第一个元素中有文本节点，所以其背景不会变成黄色；</p><p>第二个元素中有一个空格，有空格则该元素不为空，所以其背景不会变成黄色；</p><p>第三个元素中没有任何内容，所以其背景会变成黄色；</p><p>第四个元素中只有一个注释，此时该元素是空的，所以其背景会变成黄色；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;这个容器里的背景是橙色的&lt;/div&gt;</span><br><span class="line">&lt;div&gt; &lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;!-- This comment is not considered content --&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">    background: orange;</span><br><span class="line">    height: 30px;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">div:empty &#123;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>:valid 匹配条件验证正确的表单元素。</li></ul><p>如下例，当 email 输入框内的值符合 email 格式时，输入框的边框会被设为绿色。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;email&quot;/&gt;</span><br><span class="line"></span><br><span class="line">input[type=email]:valid &#123;</span><br><span class="line">    border: 1px solid green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="#0099ff" size="3" face="黑体">常用伪元素 </font><ul><li>::before/:before</li></ul><p>:before 在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;World&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">h1:before &#123;</span><br><span class="line">    content: &quot;Hello &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>::after/:after</li></ul><p>:after 在被元素后插入内容，其用法和特性与:before 相似。</p><ul><li>::first-letter/:first-letter</li></ul><p>:first-letter 匹配元素中文本的首字母。被修饰的首字母不在文档树中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h1:first-letter  &#123;</span><br><span class="line">    font-size: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>::first-line/:first-line</li></ul><p>:first-line 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p:first-line &#123;</span><br><span class="line">    background: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>::selection</li></ul><p>::selection 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加-moz 前缀。该伪元素只支持双冒号的形式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::-moz-selection &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">    background: #333;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">::selection  &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">    background: #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>::placeholder</li></ul><p>::placeholder 匹配占位符的文本，只有元素设置了 placeholder 属性时，该伪元素才能生效。</p><p>该伪元素不是 CSS 的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。</p><p>在一些浏览器中（IE10 和 Firefox18 及其以下版本）会使用单冒号的形式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;email&quot; placeholder=&quot;name@domain.com&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input::-moz-placeholder &#123;</span><br><span class="line">    color:#666;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">input::-webkit-input-placeholder &#123;</span><br><span class="line">    color:#666;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* IE 10 only */</span><br><span class="line">input:-ms-input-placeholder &#123;</span><br><span class="line">    color:#666;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* Firefox 18 and below */</span><br><span class="line">input:-moz-input-placeholder &#123;</span><br><span class="line">    color:#666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考文章-❤️"><a href="#参考文章-❤️" class="headerlink" title="参考文章 ❤️"></a>参考文章 ❤️</h2><p><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">&lt;总结伪类与伪元素</a></p><p><a href="https://swordair.com/origin-and-difference-between-css-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener">CSS伪类与CSS伪元素的区别及由来</a></p><p>v</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 伪类 </tag>
            
            <tag> 伪元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端http面试知识点</title>
      <link href="/2020/05/08/%E5%89%8D%E7%AB%AFhttp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/05/08/%E5%89%8D%E7%AB%AFhttp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码:"></a>状态码:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1xxInformational（信息状态码）接受请求正在处理</span><br><span class="line">2xxSuccess（成功状态码）               请求正常处理完毕</span><br><span class="line">3xxRedirection（重定向状态码）需要附加操作已完成请求</span><br><span class="line">4xxClient Error（客户端错误状态码）服务器无法处理请求</span><br><span class="line">5xxServer Error（服务器错误状态码）服务器处理请求出错</span><br></pre></td></tr></table></figure><h4 id="Http与Https的区别"><a href="#Http与Https的区别" class="headerlink" title="Http与Https的区别:"></a>Http与Https的区别:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头</span><br><span class="line">HTTP 是不安全的，而 HTTPS 是安全的</span><br><span class="line">HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</span><br><span class="line">在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层</span><br><span class="line">HTTP 无法加密，而HTTPS 对传输的数据进行加密</span><br><span class="line">HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书</span><br></pre></td></tr></table></figure><h4 id="一次完整的HTTP请求所经历的步骤："><a href="#一次完整的HTTP请求所经历的步骤：" class="headerlink" title="一次完整的HTTP请求所经历的步骤："></a>一次完整的HTTP请求所经历的步骤：</h4><p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><ul><li>建立TCP连接</li></ul><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p><ul><li>Web浏览器向Web服务器发送请求行</li></ul><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。</p><ul><li>Web浏览器发送请求头</li></ul><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p><ul><li>Web服务器应答</li></ul><p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p><ul><li>Web服务器发送应答头</li></ul><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p><ul><li>Web服务器向浏览器发送数据</li></ul><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p><ul><li>Web服务器关闭TCP连接</li></ul><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure></p><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接</span><br></pre></td></tr></table></figure><h4 id="不得不提“网络模型”"><a href="#不得不提“网络模型”" class="headerlink" title="不得不提“网络模型”"></a>不得不提“网络模型”</h4><p><img src="https://user-gold-cdn.xitu.io/2020/3/25/1710fd7d757baa09?w=690&amp;h=389&amp;f=png&amp;s=62404" alt></p><p>关于iso/osi7层网络模型的理解：<a href="https://blog.csdn.net/weixin_43752167/article/details/91043159" target="_blank" rel="noopener">点我带你去</a></p><h4 id="Accept和Content-Type"><a href="#Accept和Content-Type" class="headerlink" title="Accept和Content-Type"></a>Accept和Content-Type</h4><p>Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: text/html</span><br><span class="line">Accept: image/*</span><br><span class="line">Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</span><br></pre></td></tr></table></figure><p>1.Accept属于请求头， Content-Type属于实体头。<br>Http报头分为通用报头，请求报头，响应报头和实体报头。<br>请求方的http报头结构：通用报头|请求报头|实体报头<br>响应方的http报头结构：通用报头|响应报头|实体报头</p><p>2.Accept代表发送端（客户端）希望接受的数据类型。<br>比如：Accept：text/xml;<br>代表客户端希望接受的数据类型是xml类型</p><p>Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。<br>比如：Content-Type：text/html;<br>代表发送端发送的数据格式是html。</p><p>二者合起来，<br>Accept:text/xml；<br>Content-Type:text/html<br>即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。</p><h2 id="持续更新-❤️"><a href="#持续更新-❤️" class="headerlink" title="持续更新 ❤️"></a>持续更新 ❤️</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写call、apply、bind</title>
      <link href="/2020/04/20/%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind/"/>
      <url>/2020/04/20/%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind/</url>
      
        <content type="html"><![CDATA[<p>说到call、apply、bind首先是改变this指向的问题（ES5中），其次它们之间的区别，最后光<strong>说不练假把式</strong>，手写call、apply、bind！</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><p>在 ES5 中，其实 this 的指向，始终坚持一个原理： <font color="#0099ff" size="3" face="黑体">this 永远指向最后调用它的那个对象（也就是说：this取什么值是在函数执行时确定的，不是在函数定义时确定的）</font></p><ul><li>看个例子：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;如来佛祖&quot;;</span><br><span class="line">function a() &#123;</span><br><span class="line">  var name = &quot;孙悟空&quot;;</span><br><span class="line">  console.log(this.name); // 如来佛祖</span><br><span class="line">  console.log(&quot;inner:&quot; + this); //inner:[object Window]</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">console.log(&quot;outer:&quot; + this); //outer:[object Window]</span><br></pre></td></tr></table></figure><p>很简单，像上面说的 <font color="#0099ff" size="3" face="黑体">this取什么值是在函数执行时确定的</font>，最后k看调用 a 的地方 a()，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property ‘name’ of undefined。</p><ul><li>再来一个：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;如来佛祖&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">  name: &quot;孙悟空&quot;,</span><br><span class="line">  fn: function() &#123;</span><br><span class="line">    name: &quot;猪八戒&quot;,</span><br><span class="line">    console.log(this.name); //孙悟空</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">window.a.fn();</span><br></pre></td></tr></table></figure><p>为什么，这里会是孙悟空，而不是猪八戒呢，或者为什么不是如来佛祖呢，因为如上面的那句话：<font color="#0099ff" size="3" face="黑体">this取什么值是在函数执行时确定的</font>，因为，window.a.fn()就表示，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，所以name是孙悟空。</p><h2 id="改变this-的指向"><a href="#改变this-的指向" class="headerlink" title="改变this 的指向"></a>改变this 的指向</h2><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 _this = this</li><li>使用 apply、call、bind</li></ul><h4 id="使用-ES6-的箭头函数"><a href="#使用-ES6-的箭头函数" class="headerlink" title="使用 ES6 的箭头函数"></a>使用 ES6 的箭头函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;如来佛祖&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">  name: &quot;孙悟空&quot;,</span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.func1();</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2(); //孙悟空</span><br></pre></td></tr></table></figure><h4 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &quot;如来佛祖&quot;;</span><br><span class="line">var a = &#123;</span><br><span class="line">  name: &quot;孙悟空&quot;,</span><br><span class="line">  func1: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  func2: function() &#123;</span><br><span class="line">    var _this = this;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      _this.func1();</span><br><span class="line">    &#125;, 100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2(); //孙悟空</span><br></pre></td></tr></table></figure><h4 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 apply</span><br><span class="line">    var a = &#123;</span><br><span class="line">        name: &quot;孙悟空&quot;,</span><br><span class="line">        func1: function() &#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        func2: function() &#123;</span><br><span class="line">          setTimeout(</span><br><span class="line">            function() &#123;</span><br><span class="line">              this.func1();</span><br><span class="line">            &#125;.apply(a),</span><br><span class="line">            100</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    a.func2();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 call </span><br><span class="line">    var a = &#123;</span><br><span class="line">        name: &quot;孙悟空&quot;,</span><br><span class="line">        func1: function() &#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        func2: function() &#123;</span><br><span class="line">          setTimeout(</span><br><span class="line">            function() &#123;</span><br><span class="line">              this.func1();</span><br><span class="line">            &#125;.apply(a),</span><br><span class="line">            100</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    a.func2(); //孙悟空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用bind </span><br><span class="line">    var a = &#123;</span><br><span class="line">        name: &quot;孙悟空&quot;,</span><br><span class="line">        func1: function() &#123;</span><br><span class="line">          console.log(this.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        func2: function() &#123;</span><br><span class="line">          setTimeout(</span><br><span class="line">            function() &#123;</span><br><span class="line">              this.func1();</span><br><span class="line">            &#125;.bind(a)(),</span><br><span class="line">            100</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    a.func2(); //孙悟空</span><br></pre></td></tr></table></figure><h2 id="call、apply、bind的区别"><a href="#call、apply、bind的区别" class="headerlink" title="call、apply、bind的区别"></a>call、apply、bind的区别</h2><ul><li><p>call语法</p><p> fun.call(thisArg[, arg1[, arg2[, …]]])</p></li><li><p>apply语法  </p><p>fun.apply(thisArg, [argsArray])</p></li><li><p>bind语法 </p><p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p></li></ul><h2 id="手写call、apply、bind"><a href="#手写call、apply、bind" class="headerlink" title="手写call、apply、bind"></a>手写call、apply、bind</h2><p>以下内容部分来自来自 <a href="https://blog.usejournal.com/implement-your-own-call-apply-and-bind-method-in-javascript-42cc85dba1b" target="_blank" rel="noopener">Medium</a></p><ul><li>手写call</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myOwnCall = function(someOtherThis) &#123;</span><br><span class="line">    someOtherThis = someOtherThis || global;</span><br><span class="line">    var uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">    while (someOtherThis.hasOwnProperty(uniqueID)) &#123;</span><br><span class="line">      uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">    someOtherThis[uniqueID] = this;</span><br><span class="line">    const args = [];</span><br><span class="line">    </span><br><span class="line">    // arguments are saved in strings, using args</span><br><span class="line">    for (var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(&quot;arguments[&quot; + i + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // strings are reparsed into statements in the eval method</span><br><span class="line">    // Here args automatically calls the Array.toString() method.</span><br><span class="line">    var result = eval(&quot;someOtherThis[uniqueID](&quot; + args + &quot;)&quot;);</span><br><span class="line">    delete someOtherThis[uniqueID];</span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>手写apply</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.myOwnApply = function(someOtherThis, arr) &#123;</span><br><span class="line">  someOtherThis = someOtherThis || global;</span><br><span class="line">  var uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">  while (someOtherThis.hasOwnProperty(uniqueID)) &#123;</span><br><span class="line">    uniqueID = &quot;00&quot; + Math.random();</span><br><span class="line">  &#125;</span><br><span class="line">  someOtherThis[uniqueID] = this;</span><br><span class="line"></span><br><span class="line">  var args = [];</span><br><span class="line">  var result = null;</span><br><span class="line">  if (!arr) &#123;</span><br><span class="line">    result = someOtherThis[uniqueID]();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (let i = 1, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(&quot;arr[&quot; + i + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    result = eval(&quot;someOtherThis[uniqueID](&quot; + args + &quot;)&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete someOtherThis[uniqueID];</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>手写bind</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 模拟 bind</span><br><span class="line">  Function.prototype.bind1 = function() &#123;</span><br><span class="line">    //arguments获取一个函数所有的参数，它是一个列表</span><br><span class="line">    // 将参数拆解为数组</span><br><span class="line">    const args = Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    // 获取 this（数组第一项）</span><br><span class="line">    const t = args.shift();</span><br><span class="line"></span><br><span class="line">    // 好比fn1.bind(...) 中的 fn1 或者下面的_this=this</span><br><span class="line">    // const self = this;</span><br><span class="line">    _this=this</span><br><span class="line">    </span><br><span class="line">    // 返回一个函数（bind本来是返回一个函数）</span><br><span class="line">    return function() &#123;</span><br><span class="line">      // apply的第一个参数就是this</span><br><span class="line">      return _this.apply(t, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="待更新❤️，后续继续补充"><a href="#待更新❤️，后续继续补充" class="headerlink" title="待更新❤️，后续继续补充"></a>待更新❤️，后续继续补充</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> call </tag>
            
            <tag> bind </tag>
            
            <tag> apply </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>href和src有什么区别</title>
      <link href="/2020/04/10/href%E5%92%8Csrc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/04/10/href%E5%92%8Csrc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>关于这两个属性，相比前端同学都不陌生，也是前端面试的基础知识，那么知其然知其所以然，我们来聊聊它们之间的细微差距！</p><h2 id="href-VS-src："><a href="#href-VS-src：" class="headerlink" title="href VS src："></a>href VS src：</h2><ul><li>href<ul><li>href（hyperReference）即超文本引用：当浏览器遇到href时，<font size="5" color="red">会并行的地下载资源，不会阻塞页面解析</font>，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析. 因此我们在引入CSS时建议使用<link>而不是@import</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>src<ul><li>src（resource）即资源，当浏览器遇到src时，<font size="5" color="blue">会暂停页面解析，直到该资源下载或执行完毕，</font>这也是script标签之所以放底部的原因</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p><font size="5" color="blue">So，</font>两者的加载性能不同，href速度优于src!</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> href </tag>
            
            <tag> src </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试之问题集</title>
      <link href="/2020/03/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>/2020/03/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><img src="http://www.diyiziti.com/Res/Images//Temp/341/0c810ffd7dcf493c91fbdc10698abfd7.PNG" alt></p><p>半年多的前端工作经验，由于个人原因，从上家公司离职，然后一边面试一边总结经验，这篇文章会持续记录自己面试遇到的一些问题和解决措施，并且做个自我监督，奥力给！</p><hr><h2 id="vue为什么不能检测数组的变化"><a href="#vue为什么不能检测数组的变化" class="headerlink" title="vue为什么不能检测数组的变化"></a>vue为什么不能检测数组的变化</h2><p>Vue2.0对于响应式数据的实现有一些不足：</p><ul><li>无法检测数组/对象的新增</li><li>无法检测通过索引改变数组的操作。</li></ul><p><a href="https://juejin.im/post/5e1c19856fb9a0301d11ae0b" target="_blank" rel="noopener">详情链接</a></p><h2 id="为什么用Object-prototype-toString-call-obj-检测对象类型"><a href="#为什么用Object-prototype-toString-call-obj-检测对象类型" class="headerlink" title="为什么用Object.prototype.toString.call(obj)检测对象类型?"></a>为什么用Object.prototype.toString.call(obj)检测对象类型?</h2><p><a href="https://juejin.im/post/5d21e29ce51d454f6f16ec66#comment" target="_blank" rel="noopener">详情链接</a></p><h2 id="实现promise-all方法"><a href="#实现promise-all方法" class="headerlink" title="实现promise.all方法"></a>实现promise.all方法</h2><p>Promise.all()通常在启动多个异步任务并发运行并为其结果创建承诺之后使用，以便人们可以等待所有任务完成。</p><p><a href="https://juejin.im/post/5c3d702ee51d4551b747f0ac" target="_blank" rel="noopener">详情链接</a></p><h2 id="Sass-和-SCSS-有什么区别？"><a href="#Sass-和-SCSS-有什么区别？" class="headerlink" title="Sass 和 SCSS 有什么区别？"></a>Sass 和 SCSS 有什么区别？</h2><p>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：</p><ul><li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li><li>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</li></ul><p>参考文章：<a href="https://segmentfault.com/a/1190000019573996" target="_blank" rel="noopener">CSS、Sass、Scss，以及sass和scss的区别</a></p><h2 id="来个“劲爆的”，你知道forEach-、与map-的区别吗？"><a href="#来个“劲爆的”，你知道forEach-、与map-的区别吗？" class="headerlink" title="来个“劲爆的”，你知道forEach()、与map()的区别吗？"></a>来个“劲爆的”，你知道forEach()、与map()的区别吗？</h2><p>说实话，面试的时候没有答上来，我只知道：它们都是用来遍历的，但是具体区别呢，返回值呢，那时脑子短路，真没说出个所以然！ So，万丈高楼平地起，基础不扎实，会白白浪费一个offer！</p><p>唠叨罢了，还是先看看到底怎么用吧，上网查了一下，发现了两张图和一段代码，然后自己觉得这些也就够了：</p><p><strong>图一：</strong><br><img src="https://pic4.zhimg.com/80/f18b33adf235b721b009eddbc00645e9_1440w.jpg" alt></p><p><strong>图二：</strong><br><img src="https://pic4.zhimg.com/80/08235a5dafaaba6f9418704cba12fedd_1440w.jpg" alt></p><p><strong>一段代码：</strong></p><p>代码要比口语来得更清晰，很简单的实现，仅仅实现功能，没做容错处理和特别严格的上下文处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.map = function (fn) &#123;</span><br><span class="line">    var resultArray = [];</span><br><span class="line">    for (var i = 0,len = this.length; i &lt; len ; i++) &#123;</span><br><span class="line">         resultArray[i] = fn.apply(this,[this[i],i,this]);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.forEach = function (fn) &#123;</span><br><span class="line">    for (var i = 0,len = this.length; i &lt; len ; i++) &#123;</span><br><span class="line">         fn.apply(this,[this[i],i,this]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.reduce= function (fn) &#123;</span><br><span class="line">    var formerResult = this[0];</span><br><span class="line">    for (var i = 1,len = this.length; i &lt; len ; i++) &#123;</span><br><span class="line">         formerResult = fn.apply(this,[formerResult,this[i],i,this]);</span><br><span class="line">    &#125;</span><br><span class="line">    return formerResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域粗解</title>
      <link href="/2020/03/01/%E8%B7%A8%E5%9F%9F%E7%B2%97%E8%A7%A3/"/>
      <url>/2020/03/01/%E8%B7%A8%E5%9F%9F%E7%B2%97%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p> ajax 请求时<strong>浏览器</strong>要求当前网页必须和server同源（为了安全起见），必须遵循<font color="#0099ff" size="3" face="黑体">同源策略</font>，如果违背去请求数据那就是跨域</p><h4 id="那么什么是同源策略"><a href="#那么什么是同源策略" class="headerlink" title="那么什么是同源策略"></a>那么什么是同源策略</h4><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现</p><p> 简而言之： 同源就是，同源就是 <font color="#0099ff" size="3" face="黑体">协议、域名、端口三者必须一致</font></p><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h4 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h4><p>由于浏览器未做限制，script标签可以跨域请求资源</p><ul><li>优点</li></ul><p>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</p><ul><li>缺点</li></ul><p>1、只支持 GET 请求<br><br>2、由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码<br><br>3、要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题</p><h4 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h4><p> <strong>解析：</strong><br> CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持，整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>SO，<font color="#0099ff" size="3" face="黑体">实现CORS通信的关键是服务器</font>。只要服务器实现了CORS接口，就可以跨源通信。</p><p><strong>请求方式</strong></p><p> 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）</p><ul><li>请参考<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰的网络日志</a></li></ul><h4 id="CORS-VS-JSONP"><a href="#CORS-VS-JSONP" class="headerlink" title="CORS VS JSONP"></a>CORS VS JSONP</h4><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h4 id="IMG与CSS"><a href="#IMG与CSS" class="headerlink" title="IMG与CSS"></a>IMG与CSS</h4><p>由于浏览器未做限制，img标签和css也可以跨域请求资源</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;图片跨域地址&quot;/&gt;</span><br><span class="line">&lt;link herf=&quot;跨域的css地址&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。<font color="#0099ff" size="3" face="黑体">服务器代理是万能的。</font>举个栗子🌰：Nginx代理</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><font color="red" size="4" face="黑体">除上述部分，跨域解决方式还有：document.domain 跨域、window.name 跨域、location.hash 跨域、postMessage 跨域</font>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise和async await详解</title>
      <link href="/2019/07/30/Promise%E5%92%8Casync%20await%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/07/30/Promise%E5%92%8Casync%20await%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在7月份写一个项目的管理平台时，遇到的关于promise与async await的问题，下面有很好的讲解：</p><p><a href="https://juejin.im/post/5b0399bc518825426f311a3e#heading-12" target="_blank" rel="noopener">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg.js 写接口</title>
      <link href="/2019/06/24/eggjs%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/06/24/eggjs%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="egg-js-写接口"><a href="#egg-js-写接口" class="headerlink" title="egg.js 写接口"></a>egg.js 写接口</h1><p>一般可以归纳为三个部分：引入控制器, 新建类，导出类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Controller = require(&apos;egg&apos;).Controller;</span><br><span class="line"></span><br><span class="line">class NewsController extends  Controller&#123;  //类名大写</span><br><span class="line">    async list()&#123;  // async await 异步</span><br><span class="line">        const dataList = await this.data();</span><br><span class="line">        this.ctx.body = &#123;</span><br><span class="line">            code:0,</span><br><span class="line">            masg:&apos;success!&apos;,</span><br><span class="line">            data:dataList</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    async data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[</span><br><span class="line">                &#123; id: 1, title: &apos;news1&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce26578e0e5549312.png&apos; &#125;,</span><br><span class="line">                &#123; id: 2, title: &apos;news2&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657a0e01277224.png&apos; &#125;,</span><br><span class="line">                &#123; id: 3, title: &apos;news3&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657b67be250185.png&apos; &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = NewsController; //别忘了导出类,注意类名的写法，后面加Controller</span><br></pre></td></tr></table></figure><p>之后，打开app/router.js 新建一个接口 <code>router.get(&#39;/list&#39;, controller.news.list);</code> 注意路径不要写错</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = app =&gt; &#123;</span><br><span class="line">  const &#123; router, controller &#125; = app;</span><br><span class="line">  router.get(&apos;/&apos;, controller.home.index);</span><br><span class="line">  router.get(&apos;/list&apos;, controller.news.list);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完成之后就可以打开我们的前端项目进行接口请求，可以看到返回的内容。成功~</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg.js </tag>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法总结！</title>
      <link href="/2019/06/13/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/13/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=271427966,1510533885&amp;fm=26&amp;gp=0.jpg" alt="代号47"></p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><p>加粗    <strong>易灿</strong></p><p>斜体    <em>易灿</em></p><p>斜体加粗    <strong><em>乌拉</em></strong></p><p>删除线    <del>蛮吉</del></p><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><blockquote><p>引用一</p><blockquote><p>引用二</p><blockquote><p>引用三</p><p>一个&gt; 一条线</p></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个以上的 * 号和-号都可以：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>图片三种方式：</p><ol><li><p>插入本地图片<br><img src="/2019/06/13/markdown基础语法/1.jpg" alt>  (本文件放于桌面，照一张图片，重命名1.jpg就可以显示)</p></li><li><p>插入网络图片</p><p><img src="http://p1.pstatp.com/large/pgc-image/b316c7d0c5a54c459d134212be040f49" alt="飞驰人生"></p></li><li><p>把图片存入markdown文件</p><p>用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。</p><p>格式如下：</p><ul><li><p>![avatar][base64str]</p></li><li><p>[base64str]: data:image/png;base64,iVBORw0…..</p></li></ul><p><strong>但是</strong>，base64的图片编码如何得来：</p><ol><li>使用python将图片转化为base64字符串</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">f=open(&apos;723.png&apos;,&apos;rb&apos;) #二进制方式打开图文件</span><br><span class="line">ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码</span><br><span class="line">f.close()</span><br><span class="line">print(ls_f)</span><br></pre></td></tr></table></figure><ol><li>base64字符串转化为图片</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">bs=&apos;iVBORw0KGgoAAAANSUhEUg....&apos; # 太长了省略</span><br><span class="line">imgdata=base64.b64decode(bs)</span><br><span class="line">file=open(&apos;2.jpg&apos;,&apos;wb&apos;)</span><br><span class="line">file.write(imgdata)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>   语法：</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">   title可加可不加</span><br></pre></td></tr></table></figure><p><a href="http://baidu.com" target="_blank" rel="noopener">百度</a></p><p><a href="yican.fun">CAN7我的博客</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com" target="_blank">百度</a></p><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><ol><li><p>无序列表</p><p>语法：<br>无序列表用 - + * 任何一种都可以</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure></li></ol><p>效果：</p><ul><li>列表1</li></ul><ul><li>列表2</li></ul><ul><li>列表3</li></ul><ol start="2"><li><p>有序列表</p><p>语法：<br>数字加点</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure></li><li><p>列表嵌套</p><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li>一级无序列表内容<ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li>一级无序列表内容<ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li>一级有序列表内容<ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li>一级有序列表内容<ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol></li></ol><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th style="text-align:center">兵器</th><th style="text-align:right">排行</th></tr></thead><tbody><tr><td>刘备</td><td style="text-align:center">双锏</td><td style="text-align:right">大哥</td></tr><tr><td>关羽</td><td style="text-align:center">青龙偃月刀</td><td style="text-align:right">二哥</td></tr><tr><td>张飞</td><td style="text-align:center">长矛</td><td style="text-align:right">三弟</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><p>注：姓名之后没有空格</p><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p> 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> _hmt = _hmt || [];</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">     hm.src = <span class="string">"//hm.baidu.com/hm.js?0c0e9d9b1e7d617b3e6842e85b9fb068"</span>;</span><br><span class="line">     <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span><br><span class="line">     s.parentNode.insertBefore(hm, s);</span><br><span class="line">   &#125;)();</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><code>var _hmt = _hmt || [];</code></p><h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果：</span><br><span class="line"></span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure><p><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题基础NO3！</title>
      <link href="/2019/04/24/JavaScript%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/04/24/JavaScript%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript基础面试题"><a href="#JavaScript基础面试题" class="headerlink" title="JavaScript基础面试题"></a>JavaScript基础面试题</h1><h2 id="1、js基本的数据类型："><a href="#1、js基本的数据类型：" class="headerlink" title="1、js基本的数据类型："></a>1、js基本的数据类型：</h2><p>Number、String、Boolean、Null、Undefined</p><p>Object 是 JavaScript 中所有对象的父对象<br>数据封装类对象：Object、Array、Boolean、Number 和 String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error<br>新类型：Symbol</p><h2 id="2、Ajax使用"><a href="#2、Ajax使用" class="headerlink" title="2、Ajax使用"></a>2、Ajax使用</h2><p>全称 ： Asynchronous Javascript And XML<br><strong>所谓异步</strong>，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。<br>创建Ajax的过程：<br>1) 创建XMLHttpRequest对象（异步调用对象）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>2) 创建新的Http请求（方法、URL、是否异步）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.open(‘get’,’example.php’,false);</span><br></pre></td></tr></table></figure><p>3) 设置响应HTTP请求状态变化的函数。<br>onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。<br>4) 发送http请求</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><p>5) 获取异步调用返回的数据<br>注意：<br>1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。<br>2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。<br>3) 尽量减少ajax请求次数<br>4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。</p><h2 id="3、JavaScript有几种类型的值-画一下他们的内存图"><a href="#3、JavaScript有几种类型的值-画一下他们的内存图" class="headerlink" title="3、JavaScript有几种类型的值  画一下他们的内存图 "></a>3、<strong>JavaScript有几种类型的值  画一下他们的内存图 </strong></h2><p><em>基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。</em></p><p>两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h2 id="4、-什么是window对象-什么是document对象"><a href="#4、-什么是window对象-什么是document对象" class="headerlink" title="4、 什么是window对象? 什么是document对象?"></a>4、 <strong>什么是window对象? 什么是document对象?</strong></h2><p>window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。</p><h2 id="5、-关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#5、-关于事件，IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="5、 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a><strong>5、 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></h2><p>IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用<code>event.stopPropagation()</code>方法可阻止冒泡;（旧IE的方法 <code>ev.cancelBubble = true;</code>）</p><h2 id="6、-什么是闭包（closure），为什么要用它？"><a href="#6、-什么是闭包（closure），为什么要用它？" class="headerlink" title="6、 什么是闭包（closure），为什么要用它？"></a><strong>6、 什么是闭包（closure），为什么要用它？</strong></h2><p>闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。<br><strong>注意</strong>，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。<br>优点：避免全局变量污染。缺点：容易造成内存泄漏。<br>例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function makeFunc() &#123;</span><br><span class="line">    var name = &quot;Mozilla&quot;;</span><br><span class="line">    function displayName() &#123;</span><br><span class="line">        console.log(name); </span><br><span class="line">    &#125;</span><br><span class="line">    return displayName;</span><br><span class="line">&#125;</span><br><span class="line">var myFunc = makeFunc();</span><br><span class="line">myFunc();   //输出Mozilla</span><br></pre></td></tr></table></figure><p>myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。</p><h2 id="7-、对JSON的了解？"><a href="#7-、对JSON的了解？" class="headerlink" title="7 、对JSON的了解？"></a><strong>7 、对JSON的了解？</strong></h2><p>全称：JavaScript Object Notation<br>JSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。</p><p>两个函数：<br>JSON.parse(str)<br>解析JSON字符串 把JSON字符串变成JavaScript值或对象</p><p>JSON.stringify(obj)<br>将一个JavaScript值(对象或者数组)转换为一个 JSON字符串</p><p>eval(‘(‘＋json＋’)’)<br>用eval方法注意加括号 而且这种方式更容易被攻击</p><h2 id="8、documen-write和-innerHTML的区别"><a href="#8、documen-write和-innerHTML的区别" class="headerlink" title="8、documen.write和 innerHTML的区别"></a><strong>8、documen.write和 innerHTML的区别</strong></h2><p>document.write()只能重绘整个页面</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">       document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function() &#123; document.write(&quot;HI&quot;);</span><br></pre></td></tr></table></figure><p>innerHTML可以重绘页面的一部分</p><h2 id="9、DOM操作"><a href="#9、DOM操作" class="headerlink" title="9、DOM操作"></a><strong>9、DOM操作</strong></h2><p>（1）创建新节点<br>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点<br>（2）添加、移除、替换、插入<br>appendChild()<br>removeChild()<br>replaceChild()<br>insertBefore() //在已有的子节点前插入一个新的子节点<br>（3）查找<br>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)<br>getElementById() //通过元素Id，唯一性</p><h2 id="10、数组对象有哪些原生方法，列举一下"><a href="#10、数组对象有哪些原生方法，列举一下" class="headerlink" title="10、数组对象有哪些原生方法，列举一下"></a><strong>10、数组对象有哪些原生方法，列举一下</strong></h2><p>pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRight<br>forEach、map、filter、every、some</p><h2 id="11、那些操作会造成内存泄漏"><a href="#11、那些操作会造成内存泄漏" class="headerlink" title="11、那些操作会造成内存泄漏"></a><strong>11、那些操作会造成内存泄漏</strong></h2><p>全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用</p><h2 id="12、响应事件"><a href="#12、响应事件" class="headerlink" title="12、响应事件"></a><strong>12、响应事件</strong></h2><p>onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题基础NO2！</title>
      <link href="/2019/04/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前端面试基础"><a href="#前端面试基础" class="headerlink" title="前端面试基础"></a>前端面试基础</h1><h2 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h2><h3 id="1、css盒模型"><a href="#1、css盒模型" class="headerlink" title="1、css盒模型"></a>1、css盒模型</h3><ul><li>w3c盒子模型：属性width,height只包含内容content，不包含border和padding</li><li>属性width,height包含border和padding，指的是content+padding+border</li></ul><h3 id="2、居中布局"><a href="#2、居中布局" class="headerlink" title="2、居中布局"></a>2、居中布局</h3><h4 id="水平居中元素："><a href="#水平居中元素：" class="headerlink" title="水平居中元素："></a>水平居中元素：</h4><ul><li><strong>通用方法，元素的宽高未知</strong></li></ul><p>方式一：CSS3 transform </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：Flex 布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用于子元素为浮动，绝对定位，内联元素，均可水平居中。</p><ul><li><strong>居中的元素为常规文档流中的内联元素(display: inline)</strong></li></ul><p>常见的内联元素有：span, a, img, input, label 等等</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法同样适用于 display: inline-block 的元素。</p><p><strong>居中的元素为常规文档流中的块元素(display: block)</strong></p><p>常见的块元素：div, h1~h6, table, p, ul, li 等等</p><p>方式一：设置 margin</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法只能进行水平的居中，且对浮动元素或绝对定位元素无效。</p><p>方式二：修改为 inline-block 属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>居中的元素为浮动元素</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>居中的元素为绝对定位元素</strong></li></ul><p>方式一：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垂直居中元素："><a href="#垂直居中元素：" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h4><ul><li><strong>通用方法，元素的宽高未知</strong></li></ul><p>方式一：CSS3 transform</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：Flex 布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。</p><ul><li><strong>居中元素为单行文本</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把文字的 line-height 设为文字父容器的高度，适用于只有一行文字的情况。</p><ul><li><strong>已知元素宽高</strong></li></ul><p>方式一：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垂直居中元素：-1"><a href="#垂直居中元素：-1" class="headerlink" title="垂直居中元素："></a>垂直居中元素：</h4><ul><li><strong>1. 绝对居中定位</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    //absolute is ok</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">right</span>: 0;</span><br><span class="line">    <span class="selector-tag">bottom</span>: 0;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>不仅可以实现在正中间，还可以在正左方，正右方</li><li>元素的宽高支持百分比 % 属性值和 min-/max- 属性</li><li>可以封装为一个公共类，可做弹出层</li><li>浏览器支持性好</li></ol><ul><li><strong>2. 负边距居中</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>良好的跨浏览器特性,兼容 IE6 - IE7</li><li>灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性</li></ol><ul><li><strong>3. Transform 定位</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>内容可自适应，可以封装为一个公共类，可做弹出层</li><li>可能干扰其他 transform 效果</li></ol><ul><li><strong>4. Flexbox 布局</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。</p><ul><li><strong>5. table-cell 居中</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#03f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用于子元素 display 为 inline-block, inline 类型的元素，需要已知父元素的宽高，且父元素的宽高不能设为百分比数。</p><ul><li><strong>6. font-size 配合 vertical-align 实现垂直居中</strong></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">175.4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的要点是给父元素设一个合适的 font-size 的值，这个值的取值为该父元素的高度除以 1.14 得到的值，并且子元素必须 是一个 inline 或 inline-block 元素，需要加上 vertical-align: middle 属性。使用这种方法，子元素的宽度或高度都不必知道。</p><p>具体原理可以上网搜 vertical-align 垂直居中。</p><ul><li><strong>7. 文本内容**</strong>居中**</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、清除浮动"><a href="#3、清除浮动" class="headerlink" title="3、清除浮动"></a>3、清除浮动</h3><p>分析HTML结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分析CSS代码样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">      <span class="attribute">background</span>: <span class="number">#fc9</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.div1</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background</span>: darkblue;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.div2</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background</span>: darkgoldenrod;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.div3</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">background</span>: darkgreen;</span><br><span class="line">      <span class="attribute">float</span>: left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https:////upload-images.jianshu.io/upload_images/5691870-3ebe8180920ab80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p><strong>什么是浮动</strong></p><p>浮动：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来</p><h4 id="一：添加新元素，应用clear：both"><a href="#一：添加新元素，应用clear：both" class="headerlink" title="一：添加新元素，应用clear：both;"></a><strong>一：添加新元素，应用clear：both;</strong></h4><p>HTML：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5691870-18cabe86be3d5078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/996/format/webp" alt="img"></p><h4 id="二：父级div定义overflow：auto"><a href="#二：父级div定义overflow：auto" class="headerlink" title="二：父级div定义overflow：auto;"></a><strong>二：父级div定义overflow：auto;</strong></h4><p>HTML:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fc9</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto; </span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>; <span class="comment">/*zoom: 1; 是在处理兼容性问题 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三：在父级样式添加伪元素-after或者-before（推荐）"><a href="#三：在父级样式添加伪元素-after或者-before（推荐）" class="headerlink" title="三：在父级样式添加伪元素:after或者:before（推荐）"></a><strong>三：在父级样式添加伪元素:after或者:before</strong>（推荐）</h4><p>HTML:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">html   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fc9</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP相关面试题总结！</title>
      <link href="/2019/04/13/%E5%89%8D%E7%AB%AFhttp%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/04/13/%E5%89%8D%E7%AB%AFhttp%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP相关面试题总结"><a href="#HTTP相关面试题总结" class="headerlink" title="HTTP相关面试题总结"></a>HTTP相关面试题总结</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、HTTP中常用的请求方法有哪些？哪些请求方法是安全的？为什么？</span><br><span class="line"></span><br><span class="line">答：常用的请求方法有GET,POST,HEAD,PUT,DELETE。其中GET和HEAD是安全的，因为其他的三个方法都会对服务器产生动作，GET和HEAD只是请求数据，POST和POUT都会给服务端发送报文主体</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、HTTP中POST和GET方法有什么区别？</span><br><span class="line"></span><br><span class="line">答：主要有以下几点区别：</span><br><span class="line">GET请求在页面后退的时候是无害的（即不会再次发送请求），而POST会再次发送请求</span><br><span class="line">GET请求的参数是放在请求的URL中，而POST方法是放在请求体中</span><br><span class="line">GET请求在URL中传递参数时会有长度限制，而POST无限制（不是绝对的，只是相对来说）</span><br><span class="line">GET请求会被浏览器主动缓存，而POST不会</span><br><span class="line">GET请求的参数会保存在浏览器中，而POST的参数不会保存在浏览器中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、在浏览器中输入URL到页面进行渲染的过程中发生了什么？</span><br><span class="line"></span><br><span class="line">答：可以参考下面这张图理解：（参考《HTTP权威指南》）</span><br><span class="line">        浏览器解析主机名</span><br><span class="line">        DNS进行域名解析，即将语义化的主机名转换成IP地址</span><br><span class="line">        浏览器获得端口号</span><br><span class="line">        浏览器根据得到的ip地址和端口号发起TCP连接</span><br><span class="line">        浏览器发起HTTP请求</span><br><span class="line">        浏览器读取服务器返回的响应报文</span><br><span class="line">        浏览器对返回的HTML进行渲染</span><br><span class="line">        浏览器断开TCP连接</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、请简单描述一下TCP的三次握手和四次挥手的过程，两次握手可以吗？</span><br><span class="line">答：详细解答</span><br><span class="line"></span><br><span class="line"> TCP的三次握手：</span><br><span class="line"></span><br><span class="line">a.客户端发送一个SYN报文请求连接，变为SYN_SEND状态</span><br><span class="line">b.服务端接收到客户端发送SYN包，进行确认过后，发送ACK报文，变为SYN_RECV状态</span><br><span class="line">c.客户端接收到服务端的SYN和ACK报文后，发送ACK包进行确认，然后客户端和服务端都变成ESTABLISHED状态</span><br><span class="line"></span><br><span class="line"> TCP的四次挥手：</span><br><span class="line"></span><br><span class="line">a.客户端没有数据要发送了，请求关闭连接，发送一个FIN报文，并进入FIN_WAIT_1状态</span><br><span class="line">b.服务端接收到FIN报文后，发送ACK报文，然后进入CLOSE_WAIT状态；客户端接收到ACK报文后，进入FIN_WAIT_2状态</span><br><span class="line">c.服务端判断是否有数据发送给客户端，如果有的话，就将数据发送给客户端，再发送FIN报文；没有的话就直接发送FIN报文，请求关闭连接，然后进入LAST_ACK状态；</span><br><span class="line">d.客户端接收到服务端的FIN报文后，发送ACK报文，然后客户端进入TIME_WAIT状态；服务端接收到ACK报文后，关闭连接，变为CLOSED状态，客户端在2MSL后依然没有收到回复，也可以关闭连接了。</span><br><span class="line"></span><br><span class="line"> 两次握手可以吗？</span><br><span class="line"></span><br><span class="line"> 不可以，三次握手主要是防止已经过期的请求再次连接到服务端而占用资源造成浪费。如果是两次握手的话，假设主机A在发送第一次请求时，由于网络滞留的问题卡住了，很久后没有收到主机B的确认信息，于是又发送了第二次请求。过了一段时间后，第一个请求到达了主机B，主机B以为是一次新的请求，就返回确认信息，但是由于没有第三次握手，只要主机B发出确认信息，就会连接，这个时候主机B一直等待着主机A发送信息，就会造成资源浪费。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、TCP和UDP的区别是什么？</span><br><span class="line">答：主要有以下几个方面的区别：</span><br><span class="line"></span><br><span class="line">a.连接方面：TCP是面向连接的，而UDP是无连接的，即UDP在传输数据之前不需要像TCP那样3次握手建立连接</span><br><span class="line">b.可靠性：TCP比UDP更可靠，TCP可以保证不丢包，会按照顺序传输数据，这也是导致</span><br><span class="line">c.资源消耗：TCP对系统资源要求比较高，并且消耗资源比较大；UDP要求不高，但是在网络质量不好的情况下比较容易丢包，消耗资源相对比较小</span><br><span class="line">d.适用场景：TCP适用于HTTP，FTP以及邮件传输等等；而UDP比较适合于语音，视频等</span><br><span class="line">e.速度问题：TCP传输速度比较慢，效率低，在握手和挥手的过程中会占用很多时间；UDP传输速度比较快，由于是无连接的，只有传输数据的过程</span><br><span class="line">f.安全性：安全性和可靠性是不同的概念，由于TCP的机制比较多，更容易受到攻击；UDP相对来说就比较安全，但是也不能避免受到攻击</span><br><span class="line">g.连接形式：TCP是只能一对一的发送，而UDP可以是一对一，一对多，多对多</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6、HTTP中常见的状态码有哪些？分别表示什么意思？</span><br><span class="line">答：常见的状态码有：</span><br><span class="line"></span><br><span class="line">200：接收并响应成功</span><br><span class="line">301：请求的资源已经换了URL，需要重新请求（永久重定向）</span><br><span class="line">302：请求的资源临时换了URL，需要重新请求（临时重定向）</span><br><span class="line">304：在缓存中有该资源，可以直接获取</span><br><span class="line">403：该资源禁止访问</span><br><span class="line">404：该资源不存在</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7、HTTP有什么特点？HTTP有什么缺点？</span><br><span class="line">答：特点</span><br><span class="line">* 简单高效</span><br><span class="line">* 灵活</span><br><span class="line">* 无连接</span><br><span class="line">* 无状态</span><br><span class="line"></span><br><span class="line">答：有以下缺点：</span><br><span class="line"></span><br><span class="line">* 一条连接上只能发送一个请求</span><br><span class="line">* 请求只能从客户端开始，客户端不可以接收除响应之外的指令</span><br><span class="line">* 请求/响应首部未经压缩就发送，首部信息越多造成的延迟越大</span><br><span class="line">* 发送冗长的首部，每次互发相同的首部造成很大的浪费</span><br><span class="line">* 通信使用明文，内容可能会被窃听</span><br><span class="line">* 不验证通信方的身份，有可能会遭遇伪装</span><br><span class="line">* 无法验证报文的完整性，有可能遭遇篡改</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8、请描述AJAX实现原理</span><br><span class="line"></span><br><span class="line">答：AJAX的实现核心在于XMLHttpRequest这个API，主要分为以下几个步骤（参考文章：https://segmentfault.com/a/1190000017176090）：</span><br><span class="line"></span><br><span class="line">创建XMLHttpRequst对象</span><br><span class="line">初始化传进来的参数</span><br><span class="line">使用open方法发送请求</span><br><span class="line">接收请求并调用onreadystatechange方法对返回成功以及失败的情况进行定义</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9、HTTP和HTTPS的关系以及HTTPS的实现原理</span><br><span class="line">答：</span><br><span class="line"></span><br><span class="line">* HTTPS和HTTP的关系</span><br><span class="line"> HTTPS在HTTP的基础上加上了SSL协议，使得HTTP通信更加安全。针对HTTP无法验证通信方的身份，无法验证报文的完整性以及容易被窃听等安全方面的缺点，HTTPS添加了加密和认证机制，使得HTTP通信更加安全。</span><br><span class="line"></span><br><span class="line">* HTTPS通信原理（加密机制，不包括认证机制以及验证报文完整性机制，可参考这里）</span><br><span class="line">1.客户端发送请求</span><br><span class="line">2.服务端接收请求返回数字证书</span><br><span class="line">3.客户端使用内置的CA解密证书，拿到公钥</span><br><span class="line">4.如果证书没有问题，就将自己的对称秘钥使用公钥加密发送给服务端</span><br><span class="line">5.服务端使用私钥进行解密</span><br><span class="line">6.客户端和服务端使用对称秘钥进行通信</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10、webScoket是什么？主要作用是什么？</span><br><span class="line">    答：webScoket也是一种协议，用来解决要实现实时更新时，只能通过AJAX轮询等方式的问题。使用这个协议就改变了只能客户端发送请求，服务端接收请求的模式，在该协议中客户端和服务端都可以发送请求和接收请求，从而实现实时推送（服务端有数据更新后就发送数据）的功能，基于该协议可以大大的减少通信量。</span><br><span class="line"></span><br><span class="line">11、SSL有几次握手？具体过程是怎样的？</span><br><span class="line">答：这个问题和HTTPS的实现原理可以看做是一样的，但是比较有针对性，以下是回答：</span><br><span class="line"> SSL有4次握手，握手过程为：</span><br><span class="line">1.客户端请求SSL连接</span><br><span class="line">2.服务端发送包含公钥的证书</span><br><span class="line">3.客户端使用公钥加密对称秘钥并发送给服务端</span><br><span class="line">4.服务端使用私钥解密对称秘钥</span><br></pre></td></tr></table></figure><p><strong><em>文章来源：<a href="https://segmentfault.com/a/1190000017322866" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017322866</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题基础NO1！</title>
      <link href="/2019/04/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80No1/"/>
      <url>/2019/04/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80No1/</url>
      
        <content type="html"><![CDATA[<h2 id="前端基础面试题总结"><a href="#前端基础面试题总结" class="headerlink" title="前端基础面试题总结"></a>前端基础面试题总结</h2><h3 id="1、HTML5新特性"><a href="#1、HTML5新特性" class="headerlink" title="1、HTML5新特性"></a>1、HTML5新特性</h3><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>  绘画 canvas;<br>  用于媒介回放的 video 和 audio 元素;<br>  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;<br>  sessionStorage 的数据在浏览器关闭后自动删除;<br>  语意化更好的内容元素，比如 article、footer、header、nav、section;<br>  表单控件，calendar、date、time、email、url、search;<br>  新的技术webworker, websocket, Geolocation;</p><h3 id="2、关于SEO性能优化"><a href="#2、关于SEO性能优化" class="headerlink" title="2、关于SEO性能优化"></a>2、关于SEO性能优化</h3><p>（1） 减少http请求次数：CSS Sprites， JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</p><p>（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p><p>（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</p><p>（4） 当需要设置的样式很多时设置className而不是直接操作style。</p><p>（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</p><p>（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</p><p>（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。</p><p>（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<br>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的<br>浏览器中</p><h3 id="3、怎样理解语义化"><a href="#3、怎样理解语义化" class="headerlink" title="3、怎样理解语义化"></a>3、怎样理解语义化</h3><p>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;<br>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;<br>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;<br>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</p><h3 id="4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？"><a href="#4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？" class="headerlink" title="4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？"></a>4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？</h3><p>   跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。</p><p>  （1）script标签jsonp跨域；<br>  （2）nginx反向代理；<br>  （3）node.js中间代理跨域；<br>  （4）后端在头部信息设置安全域名；<br>  （5）后端在服务器上设置cors。</p><p>   jsonp跨域原理：首先在客户端注册一个callback，然后把callback的名字传给服务器，服务器生成json数据，然后以JavaScript语法生成一个function，function名字就是传递上来的参数jsonp，最后将json数据直接以参数方式放置到function中，生成js文档，返回给客户端，客户端浏览器解析script标签，并执行返回的JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数里（动态执行回调函数）</p><p>   cors跨域需要设置头部Access-Control-Allow-Origin 参数    </p><h3 id="5、谈一谈对this的理解"><a href="#5、谈一谈对this的理解" class="headerlink" title="5、谈一谈对this的理解"></a>5、谈一谈对this的理解</h3><p>通常情况下，this指向的是执行上下文中当前的对象；<br>在事件函数中，this通常指向的是事件源DOM元素对象；<br>在构造函数中，this通常指向其new所创建的对象本身。</p><p>如何绑定this</p><p>可以使用call（）、apply（）绑定<br>使用Function.prototype.bind()进行绑定<br>使用new关键字进行绑定</p><h3 id="6、call（）、apply（）、bind（）区别"><a href="#6、call（）、apply（）、bind（）区别" class="headerlink" title="6、call（）、apply（）、bind（）区别"></a>6、call（）、apply（）、bind（）区别</h3><p>apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><p>其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。</p><p>call 的语法为：<br>fun.call(thisArg[, arg1[, arg2[, …]]])<br>apply的语法为：<br>fun.apply(thisArg, [argsArray])</p><p>所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</p><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。<br>所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用</p><h3 id="7、CSS3新增"><a href="#7、CSS3新增" class="headerlink" title="7、CSS3新增"></a>7、CSS3新增</h3><p>这里可以分为边框、背景，渐变，阴影、2D转换 3D转换等之类的来说。<br>比如：边框(border-radius、border-shadow、border-image)之类的 </p><h3 id="8、vue数据双向绑定"><a href="#8、vue数据双向绑定" class="headerlink" title="8、vue数据双向绑定"></a>8、vue数据双向绑定</h3><p>利用object.defineproperty()这个方法重新定义了对象获取属性值（get）和设置属性值（set）的操作来实现的。</p><h3 id="9、前端路由"><a href="#9、前端路由" class="headerlink" title="9、前端路由"></a>9、前端路由</h3><p>通常 SPA 中前端路由有2种实现方式：<br>window.history<br>location.hash</p><h3 id="10、let-const-var有什么区别？"><a href="#10、let-const-var有什么区别？" class="headerlink" title="10、let const var有什么区别？"></a>10、let const var有什么区别？</h3><p>let是块级作用域，函数内部使用let定义后，对函数外部无影响。</p><p>const定义的变量不可以修改，而且必须初始化。<br>const b = 2;//正确 // const b;//错误，必须初始化  console.log(‘函数外const定义b：’ + b);//有输出值 // b = 5;5 // console.log(‘函数外修改const定义b：’ + b);//无法输出</p><p>var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</p><p><strong><em>文章来源：<a href="https://juejin.im/post/5ac87838f265da237314b389" target="_blank" rel="noopener">https://juejin.im/post/5ac87838f265da237314b389</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS一些面试题</title>
      <link href="/2019/04/06/JS%20%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
      <url>/2019/04/06/JS%20%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组模块："><a href="#一、数组模块：" class="headerlink" title="一、数组模块："></a>一、数组模块：</h2><h5 id="1、找出元素-item-在给定数组-arr-中的位置"><a href="#1、找出元素-item-在给定数组-arr-中的位置" class="headerlink" title="1、找出元素 item 在给定数组 arr 中的位置"></a>1、找出元素 item 在给定数组 arr 中的位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入  [ 1, 2, 3, 4 ], 3</p><p>输出  2</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexOf</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> arr.indexOf(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、数组求和"><a href="#2、数组求和" class="headerlink" title="2、数组求和"></a>2、数组求和</h5><p>计算给定数组 arr 中所有元素的总和：数组中的元素均为 Number 类型</p><p>input  [ 1, 2, 3, 4 ]    </p><p>output  10</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">不考虑算法复杂度，用递归做：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>] + sum(arr.slice(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">常规循环：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=arr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        s += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">函数式编程 map-reduce：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr, idx, arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev + curr;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">forEach遍历：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="number">0</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        s += e;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">eval</span>：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(arr.join(<span class="string">"+"</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3、移除数组中的元素"><a href="#3、移除数组中的元素" class="headerlink" title="3、移除数组中的元素"></a>3、移除数组中的元素</h5><p>移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组</p><p>输入  [1, 2, 3, 4, 2], 2  </p><p>输出  [1, 3, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//声明一个新数组保存结果</span></span><br><span class="line">     <span class="keyword">var</span> a = [];</span><br><span class="line">     <span class="comment">//循环遍历</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">         <span class="comment">//如果arr[i]不等于item，就加入数组a</span></span><br><span class="line">         <span class="keyword">if</span>(arr[i] != item)&#123;</span><br><span class="line">             a.push(arr[i]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回</p><p>输入   [1, 2, 2, 3, 4, 2, 2], 2</p><p>输出   [1, 3, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeWithoutCopy</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item)&#123;</span><br><span class="line">            arr.splice(i,<span class="number">1</span>);<span class="comment">//从数组的第i个位置开始，删除后一个元素</span></span><br><span class="line">            i--;<span class="comment">//因为他是直接删除的，那个下标会改变的,所以要自减</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">removeWithoutCopy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>,  <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>splice()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;newarr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newarr[i] == item)&#123;</span><br><span class="line">            newarr.splice(i,<span class="number">1</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>push()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newarr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != item)&#123;</span><br><span class="line">            newarr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newarr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == item)<span class="keyword">continue</span>;</span><br><span class="line">       newarr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nawarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>Arra y.prototype.filter()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr,item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ele != item;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、-添加元素"><a href="#4、-添加元素" class="headerlink" title="4、 添加元素"></a>4、 添加元素</h5><p>在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组</p><p>输入  [1, 2, 3, 4],  10</p><p>输出  [1, 2, 3, 4, 10]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        a.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(item);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],  <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组</p><p>输入   [1, 2, 3, 4], ‘z’, 2</p><p>输出  [1, 2, ‘z’, 3, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用slice+concat</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.slice(<span class="number">0</span>,index).concat(item,arr.slice(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用concat +splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr.concat();</span><br><span class="line">    newArr.splice(index,<span class="number">0</span>,item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用slice+splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr.slice(<span class="number">0</span>);</span><br><span class="line">    newArr.splice(index,<span class="number">0</span>,item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用push.apply+splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    [].push.apply(newArr, arr);</span><br><span class="line">    newArr.splice(index,<span class="number">0</span>,item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的迭代拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr, item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    newArr.splice(index,<span class="number">0</span>,item);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、删除数组最后一个元素"><a href="#5、删除数组最后一个元素" class="headerlink" title="5、删除数组最后一个元素"></a>5、删除数组最后一个元素</h5><p>删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组</p><p>输入        [1, 2, 3, 4]</p><p>输出        [1, 2, 3]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">truncate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> newArr=arr.slice(<span class="number">0</span>)<span class="comment">//slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</span></span><br><span class="line"><span class="comment">//语法  stringObject.slice(start,end)</span></span><br><span class="line">    newArr.pop()<span class="comment">//pop() 方法用于删除并返回数组的最后一个元素。</span></span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-删除数组第一个元素"><a href="#6-删除数组第一个元素" class="headerlink" title="6.删除数组第一个元素"></a>6.删除数组第一个元素</h5><p>删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组</p><p>输入        [1, 2, 3, 4]</p><p>输出        [2, 3, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curtail</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = arr.slice(<span class="number">0</span>)</span><br><span class="line">    a.shift()</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7、数组合并"><a href="#7、数组合并" class="headerlink" title="7、数组合并"></a>7、数组合并</h5><p>合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组</p><p>输入  [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1]</p><p>输出   [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用concat</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.concat(arr2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用slice+push.apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr1.slice(<span class="number">0</span>);</span><br><span class="line">    [].push.apply(newArr, arr2);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用slice+push</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=arr1.slice(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr2.length;i++)&#123;</span><br><span class="line">        newArr.push(arr2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的迭代拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">        newArr.push(arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr2.length;j++)&#123;</span><br><span class="line">        newArr.push(arr2[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8、计数"><a href="#8、计数" class="headerlink" title="8、计数"></a>8、计数</h5><p>统计数组 arr 中值等于 item 的元素出现的次数</p><p>输入  [1, 2, 4, 4, 3, 4, 3], 4</p><p>输出    3</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filter()--&gt;利用指定的函数确定是否在返回的数组中包含某一项</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a === item;   <span class="comment">//返回true的项组成的数组</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> count.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map()--&gt;对数组中的每一项进行给定函数，</span></span><br><span class="line">        <span class="comment">//返回每次函数条用的结果组成的数组；</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a === item) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === item) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//reduce()--&gt;从数组的第一项开始，逐个遍历到最后；</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, curr</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curr === item ? prev+<span class="number">1</span> : prev;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//forEach()--&gt;对数组中的每一项运行传入的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">            arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">                a === item ? count++ : <span class="number">0</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="9、查找重复元素"><a href="#9、查找重复元素" class="headerlink" title="9、查找重复元素"></a>9、查找重复元素</h5><p>找出数组 arr 中重复出现过的元素</p><p>输入    [1, 2, 4, 4, 3, 3, 1, 5, 3]</p><p>输出    [1, 3, 4]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicates</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=arr.sort(),b=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>] &amp;&amp; b.indexOf(a[i])==<span class="number">-1</span>)</span><br><span class="line">            b.push(a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;<span class="comment">//先排序，如果后一个与前一个相等且未保存，则保存。</span></span><br></pre></td></tr></table></figure><h5 id="10、-求二次方"><a href="#10、-求二次方" class="headerlink" title="10、 求二次方"></a>10、 求二次方</h5><p>为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组</p><p>输入  [1, 2, 3, 4]</p><p>输出   [1, 4, 9, 16]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = arr.slice(<span class="number">0</span>)</span><br><span class="line">    a = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val*val</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newarr = arr.slice(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//复制一个arr数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;newarr.length;i++)&#123;</span><br><span class="line">        newarr[i]= newarr[i]* newarr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newarr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item*item;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//声明一个新的数组存放结果</span></span><br><span class="line">     <span class="keyword">var</span> a = [];</span><br><span class="line">     arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//将arr中的每一个元素求平方后，加入到a数组中</span></span><br><span class="line">         a.push(e*e);</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="11、查找元素位置"><a href="#11、查找元素位置" class="headerlink" title="11、查找元素位置"></a>11、查找元素位置</h5><p>在数组 arr 中，查找值与 item 相等的元素出现的所有位置</p><p>输入  ‘abcdefabc’</p><p>输出  [0, 6]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item===target&amp;&amp;result.push(index);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]===target)&#123;</span><br><span class="line">            result.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lastIndexOf+slice/splice</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[],index=arr.lastIndexOf(target);</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        result.push(index);</span><br><span class="line">        arr.splice(index,<span class="number">1</span>);<span class="comment">//arr=arr.slice(0,index);</span></span><br><span class="line">        index=arr.lastIndexOf(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//indexOf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findAllOccurrences</span>(<span class="params">arr, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=[],index=arr.indexOf(target);</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        result.push(index);</span><br><span class="line">        index=arr.indexOf(target,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、函数部分-："><a href="#二、函数部分-：" class="headerlink" title="二、函数部分 ："></a>二、函数部分 ：</h2><h5 id="1、避免全局变量"><a href="#1、避免全局变量" class="headerlink" title="1、避免全局变量"></a>1、避免全局变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">globals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> myObject = &#123;  <span class="comment">//这里需要加 var let等关键字</span></span><br><span class="line">      name : <span class="string">'Jory'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> myObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、正确的定义函数"><a href="#2、正确的定义函数" class="headerlink" title="2、正确的定义函数"></a>2、正确的定义函数</h5><p>请修复给定的 js 代码中，函数定义存在的问题     </p><p>输入  true</p><p>输出   a  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functions</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  改正后的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functions</span>(<span class="params">flag</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">     <span class="keyword">var</span> getValue =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> getValue =<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functions(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h5 id="3、判断两个数是否相等"><a href="#3、判断两个数是否相等" class="headerlink" title="3、判断两个数是否相等"></a>3、判断两个数是否相等</h5><p>判断 val1 和 val2 是否完全等同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val1===val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以后就简写装逼</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val1===val2)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">一般使用双等来判断（==），如果还需要类型相同那么就用三等（===）。</span></span><br><span class="line"><span class="comment">说一下这两个的区别：</span></span><br><span class="line"><span class="comment">== equality 等同，=== identity 恒等。</span></span><br><span class="line"><span class="comment">==， 两边值类型不同的时候，要先进行类型转换，再比较。 </span></span><br><span class="line"><span class="comment">==，不做类型转换，类型不同的一定不等。 </span></span><br><span class="line"><span class="comment">下面分别说明： </span></span><br><span class="line"><span class="comment">先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： </span></span><br><span class="line"><span class="comment">1、如果类型不同，就[不相等] </span></span><br><span class="line"><span class="comment">2、如果两个都是数值，并且是同一个值，那么[相等]。</span></span><br><span class="line"><span class="comment">3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 </span></span><br><span class="line"><span class="comment">4、如果两个值都是true，或者都是false，那么[相等]。 </span></span><br><span class="line"><span class="comment">5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 </span></span><br><span class="line"><span class="comment">6、如果两个值都是null，或者都是undefined，那么[相等]。 </span></span><br><span class="line"><span class="comment">再说 ==，根据以下规则： </span></span><br><span class="line"><span class="comment">1、如果两个值类型相同，进行 === 比较。 </span></span><br><span class="line"><span class="comment">2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： </span></span><br><span class="line"><span class="comment">a、如果一个是null、一个是undefined，那么[相等]。 </span></span><br><span class="line"><span class="comment">b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 </span></span><br><span class="line"><span class="comment">c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 </span></span><br><span class="line"><span class="comment">d、任何其他组合，都[不相等]。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="4、计时器"><a href="#4、计时器" class="headerlink" title="4、计时器"></a>4、计时器</h5><p>实现一个打点计时器，要求<br>1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1<br>2、返回的对象中需要包含一个 cancel 方法，用于停止定时操作<br>3、第一个数需要立即输出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//立即输出第一个值</span></span><br><span class="line">  <span class="built_in">console</span>.log(start++);</span><br><span class="line">     <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">             <span class="built_in">console</span>.log(start++);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             clearInterval(timer);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//返回一个对象</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">         cancel : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             clearInterval(timer);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="5、流程控制"><a href="#5、流程控制" class="headerlink" title="5、流程控制"></a>5、流程控制</h5><p>实现 fizzBuzz 函数，参数 num 与返回值的关系如下：<br>1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz<br>2、如果 num 能被 3 整除，返回字符串 fizz<br>3、如果 num 能被 5 整除，返回字符串 buzz<br>4、如果参数为空或者不是 Number 类型，返回 false<br>5、其余情况，返回参数 num</p><p>输入: 15</p><p>输出： fizzbuzz</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; num%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fizzbuzz"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fizz"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"buzz"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="literal">null</span> || <span class="keyword">typeof</span> num != <span class="string">"number"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又一方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fizzBuzz</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = num % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> b = num % <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizzbuzz'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'fizz'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'buzz'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="string">'null'</span> || <span class="keyword">typeof</span> (num) != <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、-函数传参"><a href="#6、-函数传参" class="headerlink" title="6、 函数传参"></a>6、 函数传参</h5><p>将数组 arr 中的元素作为调用函数 fn 的参数</p><p>输入：function (greeting, name, punctuation) {</p><p>return greeting + ‘, ‘ + name + (punctuation || ‘!’);</p><p>}, [‘Hello’, ‘Ellie’, ‘!’]</p><p>输出：Hello, Ellie!</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argsAsArray</span>(<span class="params">fn, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数的三种方式</span></span><br><span class="line">obj.func();</span><br><span class="line">func.call(obj,args);<span class="comment">//参数列出</span></span><br><span class="line">func.apply(obj,[m,n......]);<span class="comment">//参数数组</span></span><br></pre></td></tr></table></figure><h5 id="7、函数的上下文"><a href="#7、函数的上下文" class="headerlink" title="7、函数的上下文"></a>7、函数的上下文</h5><p>将函数 fn 的执行上下文改为 obj 对象</p><p>输入：function () {return this.greeting + ‘, ‘ + this.name + ‘!!!’;}, {greeting: ‘Hello’, name: ‘Rebecca’}</p><p>输出：Hello, Rebecca!!!</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.apply(obj, obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="8、返回函数"><a href="#8、返回函数" class="headerlink" title="8、返回函数"></a>8、返回函数</h5><p>实现函数 functionFunction，调用之后满足如下条件：<br>1、返回值为一个函数 f<br>2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘<br>3、所有函数的参数数量为 1，且均为 String 类型</p><p>输入：functionFunction(‘Hello’)(‘world’)</p><p>输出：Hello, world</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先执行functionFunction('Hello')，传入参数str，然后返回函数f，f与('world')组合，执行f('world')，传入参数s，f返回str+", "+s，即Hello, world。注意中间的逗号后面有一个空格。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionFunction</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> str+<span class="string">", "</span>+s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> f;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="9、使用闭包"><a href="#9、使用闭包" class="headerlink" title="9、使用闭包"></a>9、使用闭包</h5><p>实现函数 makeClosures，调用之后满足如下条件：<br>1、返回一个函数数组 result，长度与 arr 相同<br>2、运行 result 中第 i 个函数，即 result<a href>i</a>，结果与 fn(arr[i]) 相同</p><p>输入：[1, 2, 3], function (x) {<br>​    return x * x;<br>}</p><p>输出：4</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> result = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(obj);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arr[i]); <span class="comment">//let声明的变量只在let所在代码块内有效，因此每次循环的i都是一个新的变量           </span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//es5的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种是错误的写法会导致result中每个函数的参数都是arr[arr.length]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arr[i]);            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参考《JavaScript高级程序设计》的典型方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fn(num);</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用ES5的bind()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] = fn.bind(<span class="literal">null</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用forEach()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeClosures</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">curr</span>)</span>&#123;</span><br><span class="line">        result.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> fn(curr)&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10、二次封装函数"><a href="#10、二次封装函数" class="headerlink" title="10、二次封装函数"></a>10、二次封装函数</h5><p>已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：<br>1、返回一个函数 result，该函数接受一个参数<br>2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致</p><p>输入：var sayIt = function(greeting, name, punctuation) {     return greeting + ‘, ‘ + name + (punctuation || ‘!’); };  partial(sayIt, ‘Hello’, ‘Ellie’)(‘!!!’);</p><p>输出：Hello, Ellie!!!</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call和apply必须显式地调用str3，立即执行</span></span><br><span class="line"><span class="comment">// bind不是立即执行，未传入str3时，并未执行，只是返回一个函数，等待参数传入</span></span><br><span class="line"><span class="comment">// this用于上下文不确定的情况</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, str1, str2, str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// apply（这里只是为了对照）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, [str1, str2, str3]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个bind会生成一个新函数（对象）, 它的str1, str2参数都定死了, str3未传入, 一旦传入就会执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.bind(<span class="keyword">this</span>, str1, str2); <span class="comment">// 或 return fn.bind(null, str1, str2);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// bind同上, 多了一步, 把str3传入的过程写在另一个函数里面,</span></span><br><span class="line"><span class="comment">// 而另一个函数也有str1, str2参数</span></span><br><span class="line"><span class="comment">// 此法有种多次一举的感觉，但是表示出了后续的调用。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn.bind(<span class="keyword">this</span>, str1, str2)(str3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 匿名函数，默认this绑定global，与bind的第一个参数为this时效果一样。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">str3</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(str1, str2, str3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// ES6。this指向undefined.</span></span><br><span class="line"><span class="keyword">const</span> partial = <span class="function">(<span class="params">fn, str1, str2</span>) =&gt;</span> str3 =&gt; fn(str1, str2, str3);</span><br></pre></td></tr></table></figure><p>实现函数 partialUsingArguments，调用之后满足如下条件：<br>1、返回一个函数 result<br>2、调用 result 之后，返回的结果与调用函数 fn 的结果一致<br>3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数</p><p>输入：无</p><p>输出：无</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ****类似与11题*****</span></span><br><span class="line"><span class="comment">//arguments不能用slice方法直接截取，需要先转换为数组，var args = Array.prototype.slice.call(arguments);合并参数可以使用concat方法，并且也需要将arguments先转换为数组才能使用concat进行合并。最用使用apply执行传入的函数即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partialUsingArguments</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//先获取p函数第一个参数之后的全部参数</span></span><br><span class="line">     <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">     <span class="comment">//声明result函数</span></span><br><span class="line">     <span class="keyword">var</span> result = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//使用concat合并两个或多个数组中的元素</span></span><br><span class="line">         <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="11、使用arguments"><a href="#11、使用arguments" class="headerlink" title="11、使用arguments"></a>11、使用arguments</h5><p>函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。</p><p>输入：1, 2, 3, 4</p><p>输出：10</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   因为参数数量不定，可以先获取参数个数arguments.length</span></span><br><span class="line"><span class="comment">   然后循环求值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//声明一个变量保存最终结果</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//循环求值</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">      sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(useArguments(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//output 10</span></span><br></pre></td></tr></table></figure><h5 id="12、使用apply-调用函数"><a href="#12、使用apply-调用函数" class="headerlink" title="12、使用apply 调用函数"></a>12、使用apply 调用函数</h5><p>实现函数 callIt，调用之后满足如下条件<br>1、返回的结果为调用 fn 之后的结果<br>2、fn 的调用参数为 callIt 的第一个参数之后的全部参数</p><p>输入：无</p><p>输出：无</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//因为arguments并非真正的数组，因此要获得callIt的第一个参数之后的所有参数，不能直接使用slice方法截取，需要先将arguments转换为真正的数组才行。有两种常见的方法，一是使用slice方法：var args = Array . prototype . slice . call ( arguments );二是循环遍历逐一填入新数组。在获得了args之后，就可以调用apply来执行传入的函数参数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将arguments转化为数组后，截取第一个元素之后的所有元素</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用fn</span></span><br><span class="line">    <span class="keyword">var</span> result = fn.apply(<span class="literal">null</span>,args);<span class="comment">//因为调用calllt的第一个参数之后的全部参数，所以这里是null </span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="13、柯里化"><a href="#13、柯里化" class="headerlink" title="13、柯里化"></a>13、柯里化</h5><p>柯里化有3个常见作用： 1. 参数复用 ；2. 提前返回；3. 延迟计算/运行</p><p>已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：<br>1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）<br>2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 1<br>3、调用 b 之后，返回一个函数 c, c 的 length 属性值为 1<br>4、调用 c 之后，返回的结果与调用 fn 的返回值一致<br>5、fn 的参数依次为函数 a, b, c 的调用参数</p><p>输入：var fn = function (a, b, c) {return a + b + c}; </p><p>​    curryIt(fn)(1)(2)(3);</p><p>输出：6</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b1 = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> b = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c1 = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> c = <span class="function"><span class="keyword">function</span>(<span class="params">g</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> a1 = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> fn.call(<span class="keyword">this</span>,d,f,g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//获取fn参数的数量</span></span><br><span class="line">     <span class="keyword">var</span> n = fn.length;</span><br><span class="line">     <span class="comment">//声明一个数组args</span></span><br><span class="line">     <span class="keyword">var</span> args = [];</span><br><span class="line">     <span class="comment">//返回一个匿名函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">         <span class="comment">//将curryIt后面括号中的参数放入数组</span></span><br><span class="line">         args.push(arg);</span><br><span class="line">         <span class="comment">//如果args中的参数个数小于fn函数的参数个数，</span></span><br><span class="line">         <span class="comment">//则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。</span></span><br><span class="line">         <span class="comment">//否则，返回fn的调用结果</span></span><br><span class="line">         <span class="keyword">if</span>(args.length &lt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">arguments</span>.callee;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">return</span> fn.apply(<span class="string">""</span>,args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="三、逻辑运算："><a href="#三、逻辑运算：" class="headerlink" title="三、逻辑运算："></a>三、逻辑运算：</h2><h5 id="1、或运算"><a href="#1、或运算" class="headerlink" title="1、或运算"></a>1、或运算</h5><p>返回参数 a 和 b 的逻辑或运算结果</p><p>输入：false, true</p><p>输出：true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">or</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a||b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、且运算"><a href="#2、且运算" class="headerlink" title="2、且运算"></a>2、且运算</h5><p>返回参数a 和 b 的逻辑且运算结果</p><p>输入：false, true</p><p>输出： false</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">functino add(a,b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a&amp;&amp;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、其它部分："><a href="#四、其它部分：" class="headerlink" title="四、其它部分："></a>四、其它部分：</h2><h5 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h5><p>完成函数 createModule，调用之后满足如下要求：<br>1、返回一个对象<br>2、对象的 greeting 属性值等于 str1， name 属性值等于 str2<br>3、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">声明对象有两种常见的方式：<span class="keyword">var</span> obj = &#123;&#125;;和<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();。前面一种可以直接在括号中以key:value的方式定义属性，后一种采用点运算符给对象添加属性。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModule</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">         greeting : str1,</span><br><span class="line">         name     : str2,</span><br><span class="line">         sayIt    : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="comment">//两个属性前面都需要加上this</span></span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">this</span>.greeting+<span class="string">", "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">return</span> obj;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(createModule(<span class="string">"11"</span>,<span class="string">"22"</span>))<span class="comment">//&#123;greeting: "11", name: "22", sayIt: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h5 id="2、二进制转换"><a href="#2、二进制转换" class="headerlink" title="2、二进制转换"></a>2、二进制转换</h5><p>获取数字 num 二进制形式第 bit 位的值。注意：<br>1、bit 从 1 开始<br>2、返回 0 或 1<br>3、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1</p><p>输入：128,8</p><p>输出：1</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">通过num.toString(<span class="number">2</span>)能直接将num转换为<span class="number">2</span>进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueAtBit</span>(<span class="params">num, bit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = num.toString(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(s);<span class="comment">//1000 0000</span></span><br><span class="line">  <span class="built_in">console</span>.log(s.length)<span class="comment">//8</span></span><br><span class="line">     <span class="keyword">return</span> s[s.length - bit];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(valueAtBit(<span class="number">128</span>,<span class="number">8</span>))<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>给定二进制字符串，将其换算成对应的十进制数字</p><p>输入：’11000000’</p><p>输出：192</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>方法可以将其它进制转换为十进制，只需要给该方法传入需要转换的字符串和该字符串的进制表示两个参数即可。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base10</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        其它进制转十进制</span></span><br><span class="line"><span class="comment">        parseInt(str,2)</span></span><br><span class="line"><span class="comment">        parseInt(str,8)</span></span><br><span class="line"><span class="comment">        parseInt(str,16)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(str,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(base10(<span class="string">'11000000'</span>))<span class="comment">//192</span></span><br></pre></td></tr></table></figure><p>将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。</p><p>输入：65</p><p>输出：01000001</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToBinary</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = num.toString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(s.length&lt;<span class="number">8</span>)&#123;</span><br><span class="line">        s = <span class="string">'0'</span>+s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先通过toString方法将num转为2进制数形式，然后判断其长度是否足够8位。如不足8位，则声明一个“0000000”字符串用于补0，因为目标的2进制数形式最少为一位，因此最多只需要7个0；通过slice方法对“0000000”进行截取，然后将其结果加在目标前面即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToBinary</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//转换为2进制格式</span></span><br><span class="line">     <span class="keyword">var</span> s = num.toString(<span class="number">2</span>);</span><br><span class="line">     <span class="comment">//获得2进制数长度</span></span><br><span class="line">     <span class="keyword">if</span>(  s.length&lt;<span class="number">8</span>)&#123;</span><br><span class="line">         <span class="comment">//声明一个字符串用于补满0</span></span><br><span class="line">         <span class="keyword">var</span> s1 = <span class="string">"0000000"</span>;</span><br><span class="line">         <span class="keyword">var</span> s2 = s1.slice(<span class="number">0</span>,<span class="number">8</span>-l);</span><br><span class="line">         s = s2+s; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="3、乘法"><a href="#3、乘法" class="headerlink" title="3、乘法"></a>3、乘法</h5><p>求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题</p><p>输入：3, 0.0001</p><p>输出：0.0003</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b*<span class="number">10000</span>*<span class="number">10000</span>/<span class="number">10000</span>/<span class="number">10000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  2</span></span><br><span class="line"><span class="comment">//根据两个书中精度较高的一个来确定，先将其转换成字符串，然后根据小数点的位置确定小数位数，</span></span><br><span class="line"><span class="comment">//字符串长度减去‘.'的位置后还要再减去1得到正确的小数位数，两个取其大，然后用toFixed()函数确定 //结果的小数位数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//求两个数中精度大的一个</span></span><br><span class="line">    <span class="keyword">var</span> stra=a.toString();</span><br><span class="line">    <span class="keyword">var</span> strb=b.toString();</span><br><span class="line">    <span class="keyword">var</span> len=<span class="built_in">Math</span>.max(stra.length-stra.indexOf(<span class="string">'.'</span>)<span class="number">-1</span>,strb.length-strb.indexOf(<span class="string">'.'</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(a*b).toFixed(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  3</span></span><br><span class="line"><span class="comment">//通过将a、b小数位数的相加，能够得到a*b结果的小数位数最大可能值。然后使用toFixed方法可以将结果的小数位数指定为可能的最大值，即保证了结果的精度。但本题实际上，仅返回a*b也能通过。在浏览器上做实验，最大17位的小数位数满足了该题全部的测试用例。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="4、改变上下文"><a href="#4、改变上下文" class="headerlink" title="4、改变上下文"></a>4、改变上下文</h5><p>将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值</p><p>输入：alterContext(function() {return this.greeting + ‘, ‘ + this.name + ‘!’; }, {name: ‘Rebecca’, greeting: ‘Yo’ })</p><p>输出：Yo, Rebecca!</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要有三种答案。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterContext</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.bind(obj)();<span class="comment">//.bind()返回的是一个函数，所以需要立即执行。 &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterContext</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterContext</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.apply(obj);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterContext</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.call(obj,obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="5、批量改变对象属性-涉及原型链问题"><a href="#5、批量改变对象属性-涉及原型链问题" class="headerlink" title="5、批量改变对象属性  (  涉及原型链问题  )"></a>5、批量改变对象属性  (  涉及原型链问题  )</h5><p>给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。</p><p>输入：var C = function(name) {this.name = name; return this;};<br>var obj1 = new C(‘Rebecca’);<br>alterObjects(C, ‘What\’s up’); obj1.greeting;</p><p>输出：What’s up</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是原型链问题。访问一个对象的方法或者是属性，首先会在该对象中寻找，如果找到则返回，如果没找到，则在其原型链上面向上寻找，直至基原型，如还未找到，则返回undefined。将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量，只需要在constructor的原型上面添加greeting属性，并指定值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alterObjects</span>(<span class="params">constructor, greeting</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//添加prototype的作用就是添加一个公共方法，或者公共属性</span></span><br><span class="line">  <span class="keyword">constructor</span>.prototype.greeting = greeting;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="6、属性遍历"><a href="#6、属性遍历" class="headerlink" title="6、属性遍历"></a>6、属性遍历</h5><p>找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)<br>1、返回数组，格式为 key: value<br>2、结果数组不要求顺序</p><p>输入：var C = function() {this.foo = ‘bar’; this.baz = ‘bim’;};<br>C.prototype.bop = ‘bip’;<br>iterate(new C());</p><p>输出：[“foo: bar”, “baz: bim”]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以使用for-in来遍历对象中的属性，hasOwnproperty方法能返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性，该属性必须为对象本身的属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> arr = [];</span><br><span class="line">     <span class="comment">//使用for-in遍历对象属性</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">         <span class="comment">//判断key是否为对象本身的属性</span></span><br><span class="line">         <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">             <span class="comment">//将属性和值按格式存入数组</span></span><br><span class="line">             arr.push(key+<span class="string">": "</span>+obj[key]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="7、判断是否包含数字（涉及正则表达式）"><a href="#7、判断是否包含数字（涉及正则表达式）" class="headerlink" title="7、判断是否包含数字（涉及正则表达式）"></a>7、判断是否包含数字（涉及正则表达式）</h5><p>给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false</p><p>输入：’abc123’</p><p>输出：true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="comment">//判断字符串中是否含有数字，可以用正则表达式。/\d/可以匹配字符串中的数字字符，用test方法可以检测。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsNumber</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> b = <span class="regexp">/\d/</span>;</span><br><span class="line">     <span class="keyword">return</span> b.test(str);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsNumber</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;str.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &gt; <span class="string">'0'</span> &amp;&amp; str[i] &lt; <span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8、检查重复字符串-正则表达式"><a href="#8、检查重复字符串-正则表达式" class="headerlink" title="8、检查重复字符串(正则表达式)"></a>8、检查重复字符串(正则表达式)</h5><p>给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false</p><p>输入：’rattler’</p><p>输出：true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\<span class="number">1</span>就是引用第一个分组，\<span class="number">2</span>就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">containsRepeatingLetter</span>(<span class="params">str</span>) </span></span><br><span class="line"><span class="function"><span class="title">return</span> /(<span class="params">[a-zA-Z]</span>)\1/.<span class="title">test</span>(<span class="params">str</span>);</span></span><br></pre></td></tr></table></figure><h5 id="9、判断是否以元音字母结尾（正则表达式）"><a href="#9、判断是否以元音字母结尾（正则表达式）" class="headerlink" title="9、判断是否以元音字母结尾（正则表达式）"></a>9、判断是否以元音字母结尾（正则表达式）</h5><p>给定字符串 str，检查其是否以元音字母结尾<br>1、元音字母包括 a，e，i，o，u，以及对应的大写<br>2、包含返回 true，否则返回 false</p><p>输入：’gorilla’</p><p>输出：true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先确定元音集合[a,e,i,o,u]，然后是以元音结尾，加上$，最后通配大小写，加上i。因此正则表达式为:/[a,e,i,o,u]$/i，最后用test方法去检测字符串str</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">endsWithVowel</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[a,e,i,o,u]$/i</span>.test(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="10、获取指定字符串-正则表达式）"><a href="#10、获取指定字符串-正则表达式）" class="headerlink" title="10、获取指定字符串(正则表达式）"></a>10、获取指定字符串(正则表达式）</h5><p>给定字符串 str，检查其是否包含 连续3个数字<br>1、如果包含，返回最新出现的 3 个数字的字符串<br>2、如果不包含，返回 false</p><p>输入：’9876543’</p><p>输出：987</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureThreeNumbers</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//声明一个数组保存匹配的字符串结果</span></span><br><span class="line">  <span class="keyword">var</span> arr = str.match(<span class="regexp">/\d&#123;3&#125;/</span>);</span><br><span class="line">     <span class="comment">//如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果</span></span><br><span class="line">     <span class="keyword">if</span>(arr)</span><br><span class="line">         <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//题目描述有问题，实际考察的是字符串中是否含有连续的三个任意数字，而不是三个连续的数字。依题，若存在连续的三个任意数字，则返回最早出现的三个数字，若不存在，则返回false。因此需要用到match方法，match()返回的是正则表达式匹配的字符串数组，连续的三个任意数字用正则表达式表示为/\d&#123;3&#125;/。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureThreeNumbers</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">     <span class="comment">//声明一个数组保存匹配的字符串结果</span></span><br><span class="line">  <span class="keyword">var</span> arr = str.match(<span class="regexp">/\d&#123;3&#125;/</span>);</span><br><span class="line">     <span class="comment">//如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果</span></span><br><span class="line">     <span class="keyword">if</span>(arr)</span><br><span class="line">         <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="11、判断是否符合指定格式-正则表达式）"><a href="#11、判断是否符合指定格式-正则表达式）" class="headerlink" title="11、判断是否符合指定格式   (正则表达式）"></a>11、判断是否符合指定格式   (正则表达式）</h5><p>给定字符串 str，检查其是否符合如下格式<br>1、XXX-XXX-XXXX<br>2、其中 X 为 Number 类型</p><p>输入：’800-555-1212’</p><p>输出：true</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本题需要注意格式，开头^和结尾$必须加上来限定字符串，3个数可表示为\d&#123;3&#125;，4个数则为\d&#123;4&#125;，&#123;n&#125;表示前面内容出现的次数。正则表达式可写作/^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$/，有相同部分\d&#123;3&#125;-，因此也可写作/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchesPattern</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="regexp">/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/</span>.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="12、判断是否符合-USD-格式-正则表达式）"><a href="#12、判断是否符合-USD-格式-正则表达式）" class="headerlink" title="12、判断是否符合 USD 格式   (正则表达式）"></a>12、判断是否符合 USD 格式   (正则表达式）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定字符串 str，检查其是否符合美元书写格式</span><br><span class="line">1、以 $ 开始</span><br><span class="line">2、整数部分，从个位起，满 3 个数字用 , 分隔</span><br><span class="line">3、如果为小数，则小数部分长度为 2</span><br><span class="line">4、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3</span><br><span class="line"></span><br><span class="line">输入：&apos;$20,933,209.93&apos;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本题注意点有必须是USD格式，以$开头，数字结尾，$和小数点的转义。</span></span><br><span class="line">首先，开头必是$，而正则表达式中$表示结尾，需要进行转义，因此开头为^\$</span><br><span class="line">然后$后必然接数字，并且最少一位，最多三位数，可用&#123;m,n&#125;表示,最少m位，最多n位，因此此段为\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">接着，后面如还有数，则必然有，分隔，并且后面必有<span class="number">3</span>个数，类似于，XXX的格式会出现<span class="number">0</span>或者n次，因此此段可表示为(,\d&#123;<span class="number">3</span>&#125;)*</span><br><span class="line">最后，如有小数部分，则注意对小数点进行转义，此段可表示为(\.\d&#123;<span class="number">2</span>&#125;)?</span><br><span class="line">因此，最后的正则表达式为/^\$\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,\d&#123;<span class="number">3</span>&#125;)*(\.\d&#123;<span class="number">2</span>&#125;)?$/</span><br><span class="line">使用test方法去检测str</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUSD</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="regexp">/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/</span>.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在window把自己的项目上传到github</title>
      <link href="/2019/04/06/%E5%9C%A8window%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
      <url>/2019/04/06/%E5%9C%A8window%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<p>1.首先简单粗暴的在GitHub上创建自己的库：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a0522d8e59421?w=1186&amp;h=833&amp;f=png&amp;s=193816" alt="img"></p><p>2.创建仓库成功后看下图，复制下图这个地址，这是这个仓库的地址，我们项目要传到这里来</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a0541861c28c5?w=1563&amp;h=797&amp;f=png&amp;s=112377" alt="img"></p><p>3.然后下载git，网上有很多教程（相信自己可以看得懂），安装后运行cd进入到自己的项目目录里（如下图）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a0577e794e439?w=746&amp;h=453&amp;f=png&amp;s=12951" alt="img"></p><p>4.然后输入<strong>git init</strong>，如下图所示，这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹）</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a05bb7b7860b1?w=752&amp;h=450&amp;f=png&amp;s=24858" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a06cdc96b4d57?w=974&amp;h=136&amp;f=png&amp;s=12930" alt="img"></p><p>第二步：</p><p>输入<strong>git add .</strong>  这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把 <strong>.</strong> 换成这个特定的文件名即可，记住<strong>add和点号中间要有空格</strong>。</p><p>第三步：</p><p>输入<strong>git commit -m “first commit”</strong>，表示你对这次提交的注释，双引号里面的内容可以根据个人的需要更改。</p><p>第四步：</p><p>输入<strong>git remote add origin https://自己的仓库url地址</strong>（上面有说到） 将本地的仓库关联到github上，</p><p>第五步：</p><p>输入<strong>git pull –rebase origin master</strong>    使得远程库与本地库一致，我们把远程库同步到本地库就可以了</p><p>第六步：</p><p>输入<strong>git push -u origin master</strong>，这是把代码上传到github仓库的意思</p><p>5.执行完后，如果没有异常，会等待几秒，然后跳出一个让你输入Username和Password 的窗口，你只要输入</p><p>github的登录账号和密码就行了。</p><p>如果你之前你已经登陆过，那么就跳过上面步骤，直接等待下图就可以了：</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/169a065360e660cb?w=495&amp;h=120&amp;f=png&amp;s=11893" alt="img"></p><p>这个是上传进度，这个过程可能有点慢，有时候大的项目要得等个10几分钟，之后去检查GitHub的仓库里有没有就可以了。</p><p><em>本次分享来源于自己的实践，参考了文章：<a href="https://blog.csdn.net/wu2374633583/article/details/7913098" target="_blank" rel="noopener">https://blog.csdn.net/wu2374633583/article/details/7913098</a></em>4</p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计网页中标签出现的个数</title>
      <link href="/2019/04/06/%E7%BB%9F%E8%AE%A1%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%A0%87%E7%AD%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/04/06/%E7%BB%9F%E8%AE%A1%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%A0%87%E7%AD%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>废话不多说直接上代码吧：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有标签</span></span><br><span class="line">       <span class="keyword">var</span> doms = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"*"</span>);</span><br><span class="line">       <span class="comment">//去重</span></span><br><span class="line">       <span class="keyword">var</span> obj =&#123;&#125;</span><br><span class="line">       <span class="keyword">var</span> ret =[]</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> j =<span class="number">0</span>;j&lt;doms.length;j++)&#123;</span><br><span class="line">           <span class="keyword">var</span> name = doms[j].nodeName</span><br><span class="line">           <span class="keyword">if</span>(!obj[name])&#123;</span><br><span class="line">               ret.push(name)</span><br><span class="line">               obj[name]=<span class="literal">true</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">console</span>.log(ret.length)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好世界</title>
      <link href="/2019/04/01/hello-world/"/>
      <url>/2019/04/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://can1177.github.io/" target="_blank" rel="noopener">CAN7</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/CAN1177" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages </tag>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何建立这个博客的！</title>
      <link href="/2019/03/23/%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
      <url>/2019/03/23/%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>本次学习完全依赖于这位不知名大佬的文章：</p><p><strong>2018，你该搭建自己的博客了！*</strong><a href="https://juejin.im/entry/5a574864f265da3e3c6c1217" target="_blank" rel="noopener">https://juejin.im/entry/5a574864f265da3e3c6c1217</a>*</p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> git管理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
