<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS一些面试题]]></title>
    <url>%2F2019%2F04%2F06%2FJS%20%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、数组模块：1、找出元素 item 在给定数组 arr 中的位置1如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1 示例1 输入 [ 1, 2, 3, 4 ], 3 输出 2 123function indexOf(arr, item) &#123; return arr.indexOf(item);&#125; 2、数组求和计算给定数组 arr 中所有元素的总和：数组中的元素均为 Number 类型 input [ 1, 2, 3, 4 ] output 10 12345678910111213141516171819202122232425262728293031323334353637不考虑算法复杂度，用递归做：function sum(arr) &#123; var len = arr.length; if(len == 0)&#123; return 0; &#125; else if (len == 1)&#123; return arr[0]; &#125; else &#123; return arr[0] + sum(arr.slice(1)); &#125;&#125;常规循环：function sum(arr) &#123; var s = 0; for (var i=arr.length-1; i&gt;=0; i--) &#123; s += arr[i]; &#125; return s;&#125;函数式编程 map-reduce：function sum(arr) &#123; return arr.reduce(function(prev, curr, idx, arr)&#123; return prev + curr; &#125;);&#125;forEach遍历：function sum(arr) &#123; var s = 0; arr.forEach(function(e) &#123; s += e; &#125;) return s;&#125;;eval：function sum(arr) &#123; return eval(arr.join("+"));&#125;; 3、移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4, 2], 2 输出 [1, 3, 4] 123456789101112function remove(arr, item) &#123; //声明一个新数组保存结果 var a = []; //循环遍历 for(var i=0; i &lt; arr.length; i++)&#123; //如果arr[i]不等于item，就加入数组a if(arr[i] != item)&#123; a.push(arr[i]); &#125; &#125; return a; &#125; 移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 输入 [1, 2, 2, 3, 4, 2, 2], 2 输出 [1, 3, 4] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function removeWithoutCopy(arr, item) &#123; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i] == item)&#123; arr.splice(i,1);//从数组的第i个位置开始，删除后一个元素 i--;//因为他是直接删除的，那个下标会改变的,所以要自减 &#125; &#125; return arr&#125; removeWithoutCopy([1, 2, 2, 4, 2, 2], 2);1.splice()function remove(arr,item)&#123; for(var i=0;i&lt;newarr.length;i++)&#123; if(newarr[i] == item)&#123; newarr.splice(i,1)； &#125; &#125; return newarr;&#125; 2.push()function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] != item)&#123; newarr.push(arr[i]); &#125; &#125; return newarr;&#125;function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] == item)continue; newarr.push(arr[i]); &#125; return nawarr;&#125;3.Arra y.prototype.filter()function remove(arr,item)&#123; return arr.filter(function(ele)&#123; return ele != item; &#125;)&#125; 4、 添加元素在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4, 10] 123456789function append(arr, item) &#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; a.push(arr[i]); &#125; a.push(item); return a;&#125;append([1, 2, 3, 4], 10); 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], ‘z’, 2 输出 [1, 2, ‘z’, 3, 4] 1234567891011121314151617181920212223242526272829303132//利用slice+concatfunction insert(arr, item, index) &#123; return arr.slice(0,index).concat(item,arr.slice(index));&#125;//利用concat +splicefunction insert(arr, item, index) &#123; var newArr=arr.concat(); newArr.splice(index,0,item); return newArr;&#125;//利用slice+splicefunction insert(arr, item, index) &#123; var newArr=arr.slice(0); newArr.splice(index,0,item); return newArr;&#125;//利用push.apply+splicefunction insert(arr, item, index) &#123; var newArr=[]; [].push.apply(newArr, arr); newArr.splice(index,0,item); return newArr;&#125;//普通的迭代拷贝function insert(arr, item, index) &#123; var newArr=[]; for(var i=0;i&lt;arr.length;i++)&#123; newArr.push(arr[i]); &#125; newArr.splice(index,0,item); return newArr;&#125; 5、删除数组最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 2, 3] 123456function truncate(arr) &#123; var newArr=arr.slice(0)//slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。//语法 stringObject.slice(start,end) newArr.pop()//pop() 方法用于删除并返回数组的最后一个元素。 return newArr&#125; 6.删除数组第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [2, 3, 4] 12345function curtail(arr) &#123; var a = arr.slice(0) a.shift() return a&#125; 7、数组合并合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1] 输出 [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1] 1234567891011121314151617181920212223242526272829//利用concatfunction concat(arr1, arr2) &#123; return arr1.concat(arr2);&#125;//利用slice+push.applyfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); [].push.apply(newArr, arr2); return newArr;&#125;//利用slice+pushfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); for(var i=0;i&lt;arr2.length;i++)&#123; newArr.push(arr2[i]); &#125; return newArr;&#125;//普通的迭代拷贝function concat(arr1, arr2) &#123; var newArr=[]; for(var i=0;i&lt;arr1.length;i++)&#123; newArr.push(arr1[i]); &#125; for(var j=0;j&lt;arr2.length;j++)&#123; newArr.push(arr2[j]); &#125; return newArr;&#125; 8、计数统计数组 arr 中值等于 item 的元素出现的次数 输入 [1, 2, 4, 4, 3, 4, 3], 4 输出 3 12345678910111213141516171819202122232425262728293031323334353637383940414243//filter()--&gt;利用指定的函数确定是否在返回的数组中包含某一项 function count(arr, item) &#123; var count = arr.filter(function(a) &#123; return a === item; //返回true的项组成的数组 &#125;); return count.length; &#125; //map()--&gt;对数组中的每一项进行给定函数， //返回每次函数条用的结果组成的数组； function count(arr, item) &#123; var count = 0; arr.map(function(a) &#123; if(a === item) &#123; count++; &#125; &#125;); return count; &#125; //for循环 function count(arr, item) &#123; var count = 0; for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] === item) &#123; count++; &#125; &#125; return count; &#125; //reduce()--&gt;从数组的第一项开始，逐个遍历到最后； function count(arr, item) &#123; var count = arr.reduce(function(prev, curr) &#123; return curr === item ? prev+1 : prev; &#125;, 0); return count; &#125; //forEach()--&gt;对数组中的每一项运行传入的函数 function count(arr, item) &#123; var count = 0; arr.forEach(function(a) &#123; a === item ? count++ : 0; &#125;); return count; &#125; 9、查找重复元素找出数组 arr 中重复出现过的元素 输入 [1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 [1, 3, 4] 12345678function duplicates(arr) &#123; var a=arr.sort(),b=[]; for(var i in a)&#123; if(a[i]==a[i-1] &amp;&amp; b.indexOf(a[i])==-1) b.push(a[i]); &#125; return b;&#125;//先排序，如果后一个与前一个相等且未保存，则保存。 10、 求二次方为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 4, 9, 16] 12345678910111213141516171819202122232425262728293031323334// 1function square(arr) &#123; var a = arr.slice(0) a = a.map(function(val) &#123; return val*val &#125;) return a&#125;function square(arr) &#123; var newarr = arr.slice(0); //复制一个arr数组 for (var i=0;i&lt;newarr.length;i++)&#123; newarr[i]= newarr[i]* newarr[i]; &#125; return newarr;&#125;// 2function square(arr) &#123; return arr.map(function(item,index,array)&#123; return item*item; &#125;)&#125;//3function square(arr) &#123; //声明一个新的数组存放结果 var a = []; arr.forEach(function(e)&#123; //将arr中的每一个元素求平方后，加入到a数组中 a.push(e*e); &#125;); return a; &#125; 11、查找元素位置在数组 arr 中，查找值与 item 相等的元素出现的所有位置 输入 ‘abcdefabc’ 输出 [0, 6] 12345678910111213141516171819202122232425262728293031323334353637//filterfunction findAllOccurrences(arr, target) &#123; var result=[]; arr.filter(function(item,index)&#123; return item===target&amp;&amp;result.push(index); &#125;); return result;&#125;//forfunction findAllOccurrences(arr, target) &#123; var result=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===target)&#123; result.push(i); &#125; &#125; return result;&#125;//lastIndexOf+slice/splicefunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.lastIndexOf(target); while(index&gt;-1)&#123; result.push(index); arr.splice(index,1);//arr=arr.slice(0,index); index=arr.lastIndexOf(target); &#125; return result;&#125;//indexOffunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.indexOf(target); while(index&gt;-1)&#123; result.push(index); index=arr.indexOf(target,index+1); &#125; return result;&#125; 二、函数部分 ：1、避免全局变量1234567function globals() &#123; var myObject = &#123; //这里需要加 var let等关键字 name : 'Jory' &#125;; return myObject;&#125; 2、正确的定义函数请修复给定的 js 代码中，函数定义存在的问题 输入 true 输出 a 123456789101112131415161718192021222324//源码function functions(flag) &#123; if (flag) &#123; function getValue() &#123; return 'a'; &#125; &#125; else &#123; function getValue() &#123; return 'b'; &#125; &#125; return getValue();&#125;// 改正后的function functions(flag) &#123; if (flag) &#123; var getValue =function() &#123; return 'a'; &#125; &#125; else &#123; var getValue =function() &#123; return 'b'; &#125; &#125; return getValue();&#125;functions(true); 3、判断两个数是否相等判断 val1 和 val2 是否完全等同 12345678910111213141516171819202122232425262728293031323334function identity(val1, val2) &#123; if(val1===val2) &#123; return true; &#125;else&#123; return false &#125;&#125;// 以后就简写装逼function identity(val1, val2) &#123; if(val1===val2)return true; else return false;&#125;/* 一般使用双等来判断（==），如果还需要类型相同那么就用三等（===）。说一下这两个的区别：== equality 等同，=== identity 恒等。==， 两边值类型不同的时候，要先进行类型转换，再比较。 ==，不做类型转换，类型不同的一定不等。 下面分别说明： 先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就[不相等] 2、如果两个都是数值，并且是同一个值，那么[相等]。3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 4、如果两个值都是true，或者都是false，那么[相等]。 5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 6、如果两个值都是null，或者都是undefined，那么[相等]。 再说 ==，根据以下规则： 1、如果两个值类型相同，进行 === 比较。 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么[相等]。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 d、任何其他组合，都[不相等]。*/ 4、计时器实现一个打点计时器，要求1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 1234567891011121314151617function count(start, end) &#123; //立即输出第一个值 console.log(start++); var timer = setInterval(function()&#123; if(start &lt;= end)&#123; console.log(start++); &#125;else&#123; clearInterval(timer); &#125; &#125;,100); //返回一个对象 return &#123; cancel : function()&#123; clearInterval(timer); &#125; &#125;; &#125; 5、流程控制实现 fizzBuzz 函数，参数 num 与返回值的关系如下：1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz2、如果 num 能被 3 整除，返回字符串 fizz3、如果 num 能被 5 整除，返回字符串 buzz4、如果参数为空或者不是 Number 类型，返回 false5、其余情况，返回参数 num 输入: 15 输出： fizzbuzz 12345678910111213141516171819202122232425262728function fizzBuzz(num) &#123; if(num%3 == 0 &amp;&amp; num%5 == 0) return "fizzbuzz"; else if(num%3 == 0) return "fizz"; else if(num%5 == 0) return "buzz"; else if(num == null || typeof num != "number") return false; else return num;&#125;//又一方法function fizzBuzz(num) &#123; var a = num % 3; var b = num % 5; if (a == 0 &amp;&amp; b == 0) &#123; return 'fizzbuzz'; &#125; else if (a == 0) &#123; return 'fizz' &#125; else if (b == 0) &#123; return 'buzz' &#125; else if (num == 'null' || typeof (num) != 'number') &#123; return false &#125; else &#123; return num &#125;&#125; 6、 函数传参将数组 arr 中的元素作为调用函数 fn 的参数 输入：function (greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }, [‘Hello’, ‘Ellie’, ‘!’] 输出：Hello, Ellie! 123456789//调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。function argsAsArray(fn, arr) &#123; return fn.apply(this, arr)&#125;// 调用函数的三种方式obj.func();func.call(obj,args);//参数列出func.apply(obj,[m,n......]);//参数数组 7、函数的上下文将函数 fn 的执行上下文改为 obj 对象 输入：function () {return this.greeting + ‘, ‘ + this.name + ‘!!!’;}, {greeting: ‘Hello’, name: ‘Rebecca’} 输出：Hello, Rebecca!!! 123456//在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function speak(fn, obj) &#123; return fn.apply(obj, obj); &#125; 8、返回函数实现函数 functionFunction，调用之后满足如下条件：1、返回值为一个函数 f2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘3、所有函数的参数数量为 1，且均为 String 类型 输入：functionFunction(‘Hello’)(‘world’) 输出：Hello, world 12345678//首先执行functionFunction('Hello')，传入参数str，然后返回函数f，f与('world')组合，执行f('world')，传入参数s，f返回str+", "+s，即Hello, world。注意中间的逗号后面有一个空格。function functionFunction(str) &#123; var f = function(s)&#123; return str+", "+s; &#125; return f; &#125; 9、使用闭包实现函数 makeClosures，调用之后满足如下条件：1、返回一个函数数组 result，长度与 arr 相同2、运行 result 中第 i 个函数，即 resulti，结果与 fn(arr[i]) 相同 输入：[1, 2, 3], function (x) {​ return x * x;} 输出：4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function makeClosures(arr, fn) &#123; var result = []; arr.forEach(function (obj) &#123; result.push(function () &#123; return fn(obj); &#125;) &#125;); return result;&#125;//es6的function makeClosures(arr, fn) &#123; var result = new Array(); for(let i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); //let声明的变量只在let所在代码块内有效，因此每次循环的i都是一个新的变量 &#125;; &#125; return result;&#125;//es5的//这种是错误的写法会导致result中每个函数的参数都是arr[arr.length]function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); &#125;; &#125; return result;&#125;//参考《JavaScript高级程序设计》的典型方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function(num)&#123; return function()&#123; return fn(num); &#125; &#125;(arr[i]); &#125; return result;&#125;//使用ES5的bind()方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = fn.bind(null,arr[i]); &#125; return result;&#125;//使用forEach()function makeClosures(arr, fn) &#123; var result = new Array(); arr.forEach(function(curr)&#123; result.push(function()&#123;return fn(curr)&#125;); &#125;) return result;&#125; 10、二次封装函数已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：1、返回一个函数 result，该函数接受一个参数2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致 输入：var sayIt = function(greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }; partial(sayIt, ‘Hello’, ‘Ellie’)(‘!!!’); 输出：Hello, Ellie!!! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// call和apply必须显式地调用str3，立即执行// bind不是立即执行，未传入str3时，并未执行，只是返回一个函数，等待参数传入// this用于上下文不确定的情况 // callfunction partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.call(this, str1, str2, str3); &#125; return result;&#125; // apply（这里只是为了对照）function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.apply(this, [str1, str2, str3]); &#125; return result;&#125; // 这个bind会生成一个新函数（对象）, 它的str1, str2参数都定死了, str3未传入, 一旦传入就会执行function partial(fn, str1, str2) &#123; return fn.bind(this, str1, str2); // 或 return fn.bind(null, str1, str2);&#125; // bind同上, 多了一步, 把str3传入的过程写在另一个函数里面,// 而另一个函数也有str1, str2参数// 此法有种多次一举的感觉，但是表示出了后续的调用。function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.bind(this, str1, str2)(str3); &#125; return result;&#125; // 匿名函数，默认this绑定global，与bind的第一个参数为this时效果一样。function partial(fn, str1, str2) &#123; return function(str3) &#123; return fn(str1, str2, str3); &#125;&#125; // ES6。this指向undefined.const partial = (fn, str1, str2) =&gt; str3 =&gt; fn(str1, str2, str3); 实现函数 partialUsingArguments，调用之后满足如下条件：1、返回一个函数 result2、调用 result 之后，返回的结果与调用函数 fn 的结果一致3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数 输入：无 输出：无 123456789101112// ****类似与11题*****//arguments不能用slice方法直接截取，需要先转换为数组，var args = Array.prototype.slice.call(arguments);合并参数可以使用concat方法，并且也需要将arguments先转换为数组才能使用concat进行合并。最用使用apply执行传入的函数即可。function partialUsingArguments(fn) &#123; //先获取p函数第一个参数之后的全部参数 var args = Array.prototype.slice.call(arguments,1); //声明result函数 var result = function()&#123; //使用concat合并两个或多个数组中的元素 return fn.apply(null, args.concat([].slice.call(arguments))); &#125; return result; &#125; 11、使用arguments函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。 输入：1, 2, 3, 4 输出：10 1234567891011121314function useArguments() &#123; /* 因为参数数量不定，可以先获取参数个数arguments.length 然后循环求值 */ //声明一个变量保存最终结果 var sum = 0; //循环求值 for(var i = 0; i &lt; arguments.length; i++)&#123; sum += arguments[i]; &#125; return sum; &#125;console.log(useArguments(1,2,3,4));//output 10 12、使用apply 调用函数实现函数 callIt，调用之后满足如下条件1、返回的结果为调用 fn 之后的结果2、fn 的调用参数为 callIt 的第一个参数之后的全部参数 输入：无 输出：无 12345678910//因为arguments并非真正的数组，因此要获得callIt的第一个参数之后的所有参数，不能直接使用slice方法截取，需要先将arguments转换为真正的数组才行。有两种常见的方法，一是使用slice方法：var args = Array . prototype . slice . call ( arguments );二是循环遍历逐一填入新数组。在获得了args之后，就可以调用apply来执行传入的函数参数。function callIt(fn) &#123; //将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); //调用fn var result = fn.apply(null,args);//因为调用calllt的第一个参数之后的全部参数，所以这里是null return result;&#125; 13、柯里化柯里化有3个常见作用： 1. 参数复用 ；2. 提前返回；3. 延迟计算/运行 已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 13、调用 b 之后，返回一个函数 c, c 的 length 属性值为 14、调用 c 之后，返回的结果与调用 fn 的返回值一致5、fn 的参数依次为函数 a, b, c 的调用参数 输入：var fn = function (a, b, c) {return a + b + c}; ​ curryIt(fn)(1)(2)(3); 输出：6 123456789101112131415161718192021222324252627282930313233function curryIt(fn) &#123; return a = function(d)&#123; var b1 = arguments[0]; return b = function(f)&#123; var c1 = arguments[0]; return c = function(g)&#123; var a1 = arguments[0]; return fn.call(this,d,f,g); &#125; &#125; &#125;&#125;//柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数。function curryIt(fn) &#123; //获取fn参数的数量 var n = fn.length; //声明一个数组args var args = []; //返回一个匿名函数 return function(arg)&#123; //将curryIt后面括号中的参数放入数组 args.push(arg); //如果args中的参数个数小于fn函数的参数个数， //则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。 //否则，返回fn的调用结果 if(args.length &lt; n)&#123; return arguments.callee; &#125;else return fn.apply("",args); &#125; &#125; 三、逻辑运算：1、或运算返回参数 a 和 b 的逻辑或运算结果 输入：false, true 输出：true 1234function or(a, b) &#123; if(a||b) return true; else return false;&#125; 2、且运算返回参数a 和 b 的逻辑且运算结果 输入：false, true 输出： false 123functino add(a,b)&#123; return a&amp;&amp;b;&#125; 四、其它部分：1、模块完成函数 createModule，调用之后满足如下要求：1、返回一个对象2、对象的 greeting 属性值等于 str1， name 属性值等于 str23、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值 12345678910111213声明对象有两种常见的方式：var obj = &#123;&#125;;和var obj = new Object();。前面一种可以直接在括号中以key:value的方式定义属性，后一种采用点运算符给对象添加属性。function createModule(str1, str2) &#123; var obj = &#123; greeting : str1, name : str2, sayIt : function()&#123; //两个属性前面都需要加上this return this.greeting+", "+this.name; &#125; &#125;; return obj; &#125; console.log(createModule("11","22"))//&#123;greeting: "11", name: "22", sayIt: ƒ&#125; 2、二进制转换获取数字 num 二进制形式第 bit 位的值。注意：1、bit 从 1 开始2、返回 0 或 13、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1 输入：128,8 输出：1 12345678910通过num.toString(2)能直接将num转换为2进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。function valueAtBit(num, bit) &#123; var s = num.toString(2); console.log(s);//1000 0000 console.log(s.length)//8 return s[s.length - bit]; &#125; console.log(valueAtBit(128,8))//1 给定二进制字符串，将其换算成对应的十进制数字 输入：’11000000’ 输出：192 123456789101112parseInt方法可以将其它进制转换为十进制，只需要给该方法传入需要转换的字符串和该字符串的进制表示两个参数即可。function base10(str) &#123; /** 其它进制转十进制 parseInt(str,2) parseInt(str,8) parseInt(str,16) */ return parseInt(str,2);&#125;console.log(base10('11000000'))//192 将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。 输入：65 输出：01000001 123456789101112131415161718192021function convertToBinary(num) &#123; var s = num.toString(2); while(s.length&lt;8)&#123; s = '0'+s; &#125; return s;&#125;//首先通过toString方法将num转为2进制数形式，然后判断其长度是否足够8位。如不足8位，则声明一个“0000000”字符串用于补0，因为目标的2进制数形式最少为一位，因此最多只需要7个0；通过slice方法对“0000000”进行截取，然后将其结果加在目标前面即可。function convertToBinary(num) &#123; //转换为2进制格式 var s = num.toString(2); //获得2进制数长度 if( s.length&lt;8)&#123; //声明一个字符串用于补满0 var s1 = "0000000"; var s2 = s1.slice(0,8-l); s = s2+s; &#125; return s; &#125; 3、乘法求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题 输入：3, 0.0001 输出：0.0003 1234567891011121314151617181920212223// 1 function multiply(a, b) &#123; return a*b*10000*10000/10000/10000&#125;// 2//根据两个书中精度较高的一个来确定，先将其转换成字符串，然后根据小数点的位置确定小数位数，//字符串长度减去‘.'的位置后还要再减去1得到正确的小数位数，两个取其大，然后用toFixed()函数确定 //结果的小数位数function multiply(a, b) &#123; //求两个数中精度大的一个 var stra=a.toString(); var strb=b.toString(); var len=Math.max(stra.length-stra.indexOf('.')-1,strb.length-strb.indexOf('.')-1); // return parseFloat(a*b).toFixed(len);&#125;// 3//通过将a、b小数位数的相加，能够得到a*b结果的小数位数最大可能值。然后使用toFixed方法可以将结果的小数位数指定为可能的最大值，即保证了结果的精度。但本题实际上，仅返回a*b也能通过。在浏览器上做实验，最大17位的小数位数满足了该题全部的测试用例。function multiply(a, b) &#123; return a*b; &#125; 4、改变上下文将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值 输入：alterContext(function() {return this.greeting + ‘, ‘ + this.name + ‘!’; }, {name: ‘Rebecca’, greeting: ‘Yo’ }) 输出：Yo, Rebecca! 12345678910111213141516//主要有三种答案。function alterContext(fn, obj) &#123; return fn.bind(obj)();//.bind()返回的是一个函数，所以需要立即执行。 &#125; function alterContext(fn, obj) &#123; return fn.call(obj);&#125; function alterContext(fn, obj) &#123; return fn.apply(obj);&#125; //在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function alterContext(fn, obj) &#123; return fn.call(obj,obj); &#125; 5、批量改变对象属性 ( 涉及原型链问题 )给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。 输入：var C = function(name) {this.name = name; return this;};var obj1 = new C(‘Rebecca’);alterObjects(C, ‘What\’s up’); obj1.greeting; 输出：What’s up 12345//这是原型链问题。访问一个对象的方法或者是属性，首先会在该对象中寻找，如果找到则返回，如果没找到，则在其原型链上面向上寻找，直至基原型，如还未找到，则返回undefined。将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量，只需要在constructor的原型上面添加greeting属性，并指定值。function alterObjects(constructor, greeting) &#123; //添加prototype的作用就是添加一个公共方法，或者公共属性 constructor.prototype.greeting = greeting; &#125; 6、属性遍历找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)1、返回数组，格式为 key: value2、结果数组不要求顺序 输入：var C = function() {this.foo = ‘bar’; this.baz = ‘bim’;};C.prototype.bop = ‘bip’;iterate(new C()); 输出：[“foo: bar”, “baz: bim”] 12345678910111213//可以使用for-in来遍历对象中的属性，hasOwnproperty方法能返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性，该属性必须为对象本身的属性。function iterate(obj) &#123; var arr = []; //使用for-in遍历对象属性 for(var key in obj)&#123; //判断key是否为对象本身的属性 if(obj.hasOwnProperty(key))&#123; //将属性和值按格式存入数组 arr.push(key+": "+obj[key]); &#125; &#125; return arr; &#125; 7、判断是否包含数字（涉及正则表达式）给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false 输入：’abc123’ 输出：true 1234567891011121314151617// 方法一//判断字符串中是否含有数字，可以用正则表达式。/\d/可以匹配字符串中的数字字符，用test方法可以检测。function containsNumber(str) &#123; var b = /\d/; return b.test(str); &#125;//方法二function containsNumber(str) &#123; for(var i=0 ; i&lt;str.length ; i++)&#123; if(str[i] &gt; '0' &amp;&amp; str[i] &lt; '9')&#123; return true; &#125; &#125; return false;&#125; 8、检查重复字符串(正则表达式)给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 输入：’rattler’ 输出：true 1234在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\1就是引用第一个分组，\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。function containsRepeatingLetter(str) return /([a-zA-Z])\1/.test(str); 9、判断是否以元音字母结尾（正则表达式）给定字符串 str，检查其是否以元音字母结尾1、元音字母包括 a，e，i，o，u，以及对应的大写2、包含返回 true，否则返回 false 输入：’gorilla’ 输出：true 12345//首先确定元音集合[a,e,i,o,u]，然后是以元音结尾，加上$，最后通配大小写，加上i。因此正则表达式为:/[a,e,i,o,u]$/i，最后用test方法去检测字符串strfunction endsWithVowel(str) &#123; return /[a,e,i,o,u]$/i.test(str); &#125; 10、获取指定字符串(正则表达式）给定字符串 str，检查其是否包含 连续3个数字1、如果包含，返回最新出现的 3 个数字的字符串2、如果不包含，返回 false 输入：’9876543’ 输出：987 12345678910111213141516171819function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false;&#125;//题目描述有问题，实际考察的是字符串中是否含有连续的三个任意数字，而不是三个连续的数字。依题，若存在连续的三个任意数字，则返回最早出现的三个数字，若不存在，则返回false。因此需要用到match方法，match()返回的是正则表达式匹配的字符串数组，连续的三个任意数字用正则表达式表示为/\d&#123;3&#125;/。function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false; &#125; 11、判断是否符合指定格式 (正则表达式）给定字符串 str，检查其是否符合如下格式1、XXX-XXX-XXXX2、其中 X 为 Number 类型 输入：’800-555-1212’ 输出：true 1234//本题需要注意格式，开头^和结尾$必须加上来限定字符串，3个数可表示为\d&#123;3&#125;，4个数则为\d&#123;4&#125;，&#123;n&#125;表示前面内容出现的次数。正则表达式可写作/^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$/，有相同部分\d&#123;3&#125;-，因此也可写作/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/function matchesPattern(str) &#123; return/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 12、判断是否符合 USD 格式 (正则表达式）12345678给定字符串 str，检查其是否符合美元书写格式1、以 $ 开始2、整数部分，从个位起，满 3 个数字用 , 分隔3、如果为小数，则小数部分长度为 24、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3输入：&apos;$20,933,209.93&apos;输出：true 12345678910//本题注意点有必须是USD格式，以$开头，数字结尾，$和小数点的转义。首先，开头必是$，而正则表达式中$表示结尾，需要进行转义，因此开头为^\$然后$后必然接数字，并且最少一位，最多三位数，可用&#123;m,n&#125;表示,最少m位，最多n位，因此此段为\d&#123;1,3&#125;接着，后面如还有数，则必然有，分隔，并且后面必有3个数，类似于，XXX的格式会出现0或者n次，因此此段可表示为(,\d&#123;3&#125;)*最后，如有小数部分，则注意对小数点进行转义，此段可表示为(\.\d&#123;2&#125;)?因此，最后的正则表达式为/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/使用test方法去检测strfunction isUSD(str) &#123; return /^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/.test(str);&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在window把自己的项目上传到github]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%9C%A8window%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[1.首先简单粗暴的在GitHub上创建自己的库： 2.创建仓库成功后看下图，复制下图这个地址，这是这个仓库的地址，我们项目要传到这里来 3.然后下载git，网上有很多教程（相信自己可以看得懂），安装后运行cd进入到自己的项目目录里（如下图）： 4.然后输入git init，如下图所示，这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹） 第二步： 输入git add . 这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把 . 换成这个特定的文件名即可，记住add和点号中间要有空格。 第三步： 输入git commit -m “first commit”，表示你对这次提交的注释，双引号里面的内容可以根据个人的需要更改。 第四步： 输入git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上， 第五步： 输入git pull –rebase origin master 使得远程库与本地库一致，我们把远程库同步到本地库就可以了 第六步： 输入git push -u origin master，这是把代码上传到github仓库的意思 5.执行完后，如果没有异常，会等待几秒，然后跳出一个让你输入Username和Password 的窗口，你只要输入 github的登录账号和密码就行了。 如果你之前你已经登陆过，那么就跳过上面步骤，直接等待下图就可以了： 这个是上传进度，这个过程可能有点慢，有时候大的项目要得等个10几分钟，之后去检查GitHub的仓库里有没有就可以了。 本次分享来源于自己的实践，参考了文章：https://blog.csdn.net/wu2374633583/article/details/79130984]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网页中标签出现的个数]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%BB%9F%E8%AE%A1%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%A0%87%E7%AD%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[废话不多说直接上代码吧： 12345678910111213//获取所有标签 var doms = document.getElementsByTagName("*"); //去重 var obj =&#123;&#125; var ret =[] for(var j =0;j&lt;doms.length;j++)&#123; var name = doms[j].nodeName if(!obj[name])&#123; ret.push(name) obj[name]=true &#125; &#125; console.log(ret.length)]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2019%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to CAN7! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是如何建立这个博客的！]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[本次学习完全依赖于这位不知名大佬的文章： 2018，你该搭建自己的博客了！*https://juejin.im/entry/5a574864f265da3e3c6c1217*]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>git管理</tag>
      </tags>
  </entry>
</search>
