<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise和async await详解]]></title>
    <url>%2F2019%2F07%2F30%2FPromise%E5%92%8Casync%20await%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在7月份写一个项目的管理平台时，遇到的关于promise与async await的问题，下面有很好的讲解： 点击这里]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[egg.js 写接口]]></title>
    <url>%2F2019%2F06%2F24%2Feggjs%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[egg.js 写接口一般可以归纳为三个部分：引入控制器, 新建类，导出类 123456789101112131415161718192021222324const Controller = require(&apos;egg&apos;).Controller;class NewsController extends Controller&#123; //类名大写 async list()&#123; // async await 异步 const dataList = await this.data(); this.ctx.body = &#123; code:0, masg:&apos;success!&apos;, data:dataList &#125;; &#125; async data()&#123; return &#123; list:[ &#123; id: 1, title: &apos;news1&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce26578e0e5549312.png&apos; &#125;, &#123; id: 2, title: &apos;news2&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657a0e01277224.png&apos; &#125;, &#123; id: 3, title: &apos;news3&apos;, url: &apos;https://i.loli.net/2019/05/20/5ce2657b67be250185.png&apos; &#125;, ] &#125; &#125;&#125;module.exports = NewsController; //别忘了导出类,注意类名的写法，后面加Controller 之后，打开app/router.js 新建一个接口 router.get(&#39;/list&#39;, controller.news.list); 注意路径不要写错 12345module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&apos;/&apos;, controller.home.index); router.get(&apos;/list&apos;, controller.news.list);&#125;; 完成之后就可以打开我们的前端项目进行接口请求，可以看到返回的内容。成功~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>egg.js</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法总结！]]></title>
    <url>%2F2019%2F06%2F13%2Fmarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、标题一级标题二级标题三级标题四级标题五级标题六级标题二、字体加粗 易灿 斜体 易灿 斜体加粗 乌拉 删除线 蛮吉 三、引用 引用一 引用二 引用三 一个&gt; 一条线 四、分割线三个以上的 * 号和-号都可以： 1234-------******** 效果如下： 五、图片图片三种方式： 插入本地图片 (本文件放于桌面，照一张图片，重命名1.jpg就可以显示) 插入网络图片 把图片存入markdown文件 用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置。 格式如下： ![avatar][base64str] [base64str]: data:image/png;base64,iVBORw0….. 但是，base64的图片编码如何得来： 使用python将图片转化为base64字符串 12345import base64f=open(&apos;723.png&apos;,&apos;rb&apos;) #二进制方式打开图文件ls_f=base64.b64encode(f.read()) #读取文件内容，转换为base64编码f.close()print(ls_f) base64字符串转化为图片 123456import base64bs=&apos;iVBORw0KGgoAAAANSUhEUg....&apos; # 太长了省略imgdata=base64.b64decode(bs)file=open(&apos;2.jpg&apos;,&apos;wb&apos;)file.write(imgdata)file.close() 六、超链接 语法： 12[超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 百度 CAN7我的博客 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 百度 七、列表 无序列表 语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果： 列表1 列表2 列表3 有序列表 语法：数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 姓名 兵器 排行 刘备 双锏 大哥 关羽 青龙偃月刀 二哥 张飞 长矛 三弟 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 注：姓名之后没有空格 九、代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 123456789&lt;script&gt; var _hmt = _hmt || []; (function() &#123; var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?0c0e9d9b1e7d617b3e6842e85b9fb068"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); &#125;)(); &lt;/script&gt; var _hmt = _hmt || []; 十、流程图语法： 123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 123456789101112效果：```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; `]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吐槽才能开心]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%90%90%E6%A7%BD%E6%97%B6%E5%88%BB%2F</url>
    <content type="text"><![CDATA[吐槽时刻自己从面试准备结束之后，就忙于一些学校的杂事，四年大学在一所甘肃的普通二本度过，专业为信息管理与信息系统。最后，竟然颁发的是管理学学位。无疑，我觉得这是一种”耻辱”。 这段时间自己无非就是写了个破设计，全班43个人，除了3个人自己写的设计和一个人写的论文外，其他39个人，都是买来现成，再加工 （这不是鄙视，或者什么，只是一种无奈）。 这就是自己的一些简单吐槽吧，感觉这几天生活乱乱的，代码几乎没敲，每天浑浑噩噩的睡去，醒来，自己还生病了。想去找个人去说说，但想想还不如自己戴耳机写博客来的舒服一些。嗯嗯，就好比自己自言自语，说着一些自己的一些事情，给另一个自己听。 舒服，虽然就写了这么些字！！！]]></content>
      <categories>
        <category>自己</category>
      </categories>
      <tags>
        <tag>吐槽</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一次面试！]]></title>
    <url>%2F2019%2F04%2F30%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[我的第一次面试​ 2019年4月30日号进行了我的人生中第一次面试，应聘岗位是前端开发，说实话有点紧张，但是面试官给力。好啦，直击面试题吧，属于中下等级，但是自己回答的不太好（当时属于五五开），下面整理了自己没有回答好的题目： 1、了解ES6吗？什么是JavaScript JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。（好吧，概念什么最讨厌了） 动态： 在运行时确定数据类型。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 弱类： 计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。 原型： 新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。 PS：新对象指函数，模版对象是实例对象，实例对象是不能继承原型的，函数才可以的。 JavaScript由三部分组成： **1. ECMAScript（核心）** 作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象 PS：*不完全兼容的实现 **2. DOM（文档对象模型）** DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。 **3. BOM （浏览器对象模型）** 支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 PS：BOM未形成规范 什么是ES5 作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下。 \1. strict模式 严格模式，限制一些用法，’use strict’; \2. Array增加方法 增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法 PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now \3. Object方法 Object.getPrototypeOf Object.create Object.getOwnPropertyNames Object.defineProperty Object.getOwnPropertyDescriptor Object.defineProperties Object.keys Object.preventExtensions / Object.isExtensible Object.seal / Object.isSealed Object.freeze / Object.isFrozen PS：只讲有什么，不讲是什么。 什么是ES6 ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下： ES6特性如下： 1.块级作用域 关键字let, 常量const 2.对象字面量的属性赋值简写（property value shorthand） ;) 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &apos;prop_&apos; + (() =&gt; 42)() ]: 42&#125;; ;) 3.赋值解构 1234let singer = &#123; first: &quot;Bob&quot;, last: &quot;Dylan&quot; &#125;;let &#123; first: f, last: l &#125; = singer; // 相当于 f = &quot;Bob&quot;, l = &quot;Dylan&quot;let [all, year, month, day] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec(&quot;2015-10-25&quot;);let [x, y] = [1, 2, 3]; // x = 1, y = 2 4.函数参数 - 默认值、参数打包、 数组展开（Default 、Rest 、Spread） ;) 123456789101112131415161718//Defaultfunction findArtist(name=&apos;lu&apos;, age=&apos;26&apos;) &#123; ...&#125;//Restfunction f(x, ...y) &#123; // y is an Array return x * y.length;&#125;f(3, &quot;hello&quot;, true) == 6//Spreadfunction f(x, y, z) &#123; return x + y + z;&#125;// Pass each elem of array as argumentf(...[1,2,3]) == 6 ;) 5.箭头函数 Arrow functions (1).简化了代码形式，默认return表达式结果。 (2).自动绑定语义this，即定义函数时的this。如上面例子中，forEach的匿名函数参数中用到的this。 6.字符串模板 Template strings 123var name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`// return &quot;Hello Bob, how are you today?&quot; \7. Iterators（迭代器）+ for..of 迭代器有个next方法，调用会返回： (1).返回迭代对象的一个元素：{ done: false, value: elem } (2).如果已到迭代对象的末端：{ done: true, value: retVal } 1234for (var n of [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]) &#123; console.log(n);&#125;// 打印a、b、c 8.生成器 （Generators） 9.Class Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。 ;) 123456789101112131415161718192021222324252627class Artist &#123; constructor(name) &#123; this.name = name; &#125; perform() &#123; return this.name + &quot; performs &quot;; &#125;&#125;class Singer extends Artist &#123; constructor(name, song) &#123; super.constructor(name); this.song = song; &#125; perform() &#123; return super.perform() + &quot;[&quot; + this.song + &quot;]&quot;; &#125;&#125;let james = new Singer(&quot;Etta James&quot;, &quot;At last&quot;);james instanceof Artist; // truejames instanceof Singer; // truejames.perform(); // &quot;Etta James performs [At last]&quot; ;) 10.Modules ES6的内置模块功能借鉴了CommonJS和AMD各自的优点： (1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。 (2).类似AMD，支持异步加载和可配置的模块加载。 ;) 1234567891011121314151617181920212223// lib/math.jsexport function sum(x, y) &#123; return x + y;&#125;export var pi = 3.141593;// app.jsimport * as math from &quot;lib/math&quot;;alert(&quot;2π = &quot; + math.sum(math.pi, math.pi));// otherApp.jsimport &#123;sum, pi&#125; from &quot;lib/math&quot;;alert(&quot;2π = &quot; + sum(pi, pi));Module Loaders:// Dynamic loading – ‘System’ is default loaderSystem.import(&apos;lib/math&apos;).then(function(m) &#123; alert(&quot;2π = &quot; + m.sum(m.pi, m.pi));&#125;);// Directly manipulate module cacheSystem.get(&apos;jquery&apos;);System.set(&apos;jquery&apos;, Module(&#123;$: $&#125;)); // WARNING: not yet finalized ;) 11.Map + Set + WeakMap + WeakSet 四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。 ;) 1234567891011121314151617181920// Setsvar s = new Set();s.add(&quot;hello&quot;).add(&quot;goodbye&quot;).add(&quot;hello&quot;);s.size === 2;s.has(&quot;hello&quot;) === true;// Mapsvar m = new Map();m.set(&quot;hello&quot;, 42);m.set(s, 34);m.get(s) == 34;//WeakMapvar wm = new WeakMap();wm.set(s, &#123; extra: 42 &#125;);wm.size === undefined// Weak Setsvar ws = new WeakSet();ws.add(&#123; data: 42 &#125;);//Because the added object has no other references, it will not be held in the set ;) 12.Math + Number + String + Array + Object APIs 一些新的API ;) 1234567891011121314151617181920212223Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(&quot;NaN&quot;) // falseMath.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2&quot;abcde&quot;.includes(&quot;cd&quot;) // true&quot;abc&quot;.repeat(3) // &quot;abcabcabc&quot;Array.from(document.querySelectorAll(&apos;*&apos;)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(...), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1, 2, 3].find(x =&gt; x == 3) // 3[1, 2, 3].findIndex(x =&gt; x == 2) // 1[1, 2, 3, 4, 5].copyWithin(3, 0) // [1, 2, 3, 1, 2][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].entries() // iterator [0, &quot;a&quot;], [1,&quot;b&quot;], [2,&quot;c&quot;][&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].keys() // iterator 0, 1, 2[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].values() // iterator &quot;a&quot;, &quot;b&quot;, &quot;c&quot;Object.assign(Point, &#123; origin: new Point(0,0) &#125;) ;) \13. Proxies 使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。 ;) 123456789var target = &#123;&#125;;var handler = &#123; get: function (receiver, name) &#123; return `Hello, $&#123;name&#125;!`; &#125;&#125;;var p = new Proxy(target, handler);p.world === &apos;Hello, world!&apos;; ;) 可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。 14.Symbols Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。 123var key = Symbol(&quot;key&quot;);var key2 = Symbol(&quot;key&quot;);key == key2 //false 15.Promises Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的deferred 对象）。 ;) 12345678910111213141516function fakeAjax(url) &#123; return new Promise(function (resolve, reject) &#123; // setTimeouts are for effect, typically we would handle XHR if (!url) &#123; return setTimeout(reject, 1000); &#125; return setTimeout(resolve, 1000); &#125;);&#125;// no url, promise rejectedfakeAjax().then(function () &#123; console.log(&apos;success&apos;);&#125;,function () &#123; console.log(&apos;fail&apos;);&#125;); ;) 2、HTTP状态保持的原理​ 首先我们要知道Http是无状态的，就是连接时数据进行交互，关闭后服务端课客户端彼此不认识彼此，或者说永久性失忆，那么为什么http是无状态的呢？因为浏览器和服务器之间用的是socket通信，也就是TCP通信，一旦关闭浏览器，四次挥手之后就销毁所有交互信息（这里涉及TCP的三次握手和四次挥手，感兴趣童鞋可以自行查阅相关资料）。这就涉及浏览器跟服务器之间保持状态的方法，也就是cookie。具体分为以下四个步骤： ​ 1、在用户登录之后，浏览器返回响应的时候会在响应中添加上cookie ​ 2、浏览器接收到cookie之后会自动保存 ​ 3、当用户再次请求同一服务器中的其他网页的时候，浏览器会自动带上之前保存的cookie ​ 4、服务接收到请求之后可以请 request 对象中取到cookie 判断当前用户是否登录 ​ 但是cookie保存在浏览器，每次访问网站都会将本地保存cookies值（一般用来存储用户个人信息）发送到网站，不安全。这个时候也就产生了session。Seesion虽然依赖cookie存在，但它保存在服务器上，比cookie更安全。而且session存的数字不会转成字符串，而cookie存值会转为字符串。 3、JS引用类型与基本类型的区别1)基本类型的值是一经确定就不可变的(2)基本类型的比较是值的比较只有在它们的值相等的时候它们才相等。当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。123var a = 1;var b = true;console.log(a == b);//true复制代码 在用==比较两个不同类型的变量时会进行一些类型转换。如上的比较先会把true转换为数字1再和数字1进行比较，结果就是true了。123var a = &apos;coco&apos;;var b = &apos;coco&apos;;console.log(a === b);//true复制代码 (3)基本类型的变量是存放在栈区的（栈区指内存里的栈内存）123var name = &apos;coco&apos;;var city = &apos;shenzhen&apos;;var age = 24;复制代码 存储结构如下：这里写图片描述 栈区包括了 变量的标识符和变量的值。(4)引用类型的值是可变的可以为引用类型添加属性和方法，也可以删除其属性和方法。12345678910111213141516var person = &#123;&#125;;//创建一个空对象 --引用类型person.name = &apos;coco&apos;;person.age = 24;person.sayName = function()&#123;console.log(person.name);&#125; person.sayName();// &apos;coco&apos;复制代码var person = &#123;&#125;;//创建一个空对象 --引用类型person.name = &apos;coco&apos;;person.age = 24;person.sayName = function()&#123;console.log(person.name);&#125; person.sayName();// &apos;coco&apos;delete person.name; //删除person对象的name属性person.sayName(); // undefined复制代码 引用类型可以拥有属性和方法，并且是可以动态改变的。(5)引用类型的值是同时保存在栈内存和堆内存中的对象js不同于其他语言，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，实际上，是操作对象的引用，所以引用类型的值是按引用访问的。准确地说，引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址。123var person1 = &#123;name:&apos;zhangsan&apos;&#125;;var person2 = &#123;name:&apos;lisi&apos;&#125;;var person3 = &#123;name:&apos;wangwu&apos;&#125;;复制代码 则这三个对象的在内存中保存的情况如下图：这里写图片描述 (6)引用类型的比较是引用的比较123var person1 = &apos;&#123;&#125;&apos;;var person2 = &apos;&#123;&#125;&apos;;console.log(person1 == person2); // true复制代码 基本类型的比较–当两个比较值的类型相同的时候，相当于是用 === ，所以输出是true。123var person1 = &#123;&#125;;var person2 = &#123;&#125;;console.log(person1 == person2); // false复制代码 上面比较的是两个字符串，而下面比较的是两个对象，为什么长的一模一样的对象就不相等了呢？引用类型是按引用访问的，换句话说就是比较两个对象的堆内存中的地址是否相同，那很明显，person1和person2在堆内存中地址是不同的：这里写图片描述 这两个是完全不同的对象，所以返回false。4、对于箭头函数你了解多少？直接看这个链接]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO3！]]></title>
    <url>%2F2019%2F04%2F24%2FJavaScript%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[JavaScript基础面试题1、js基本的数据类型：Number、String、Boolean、Null、Undefined Object 是 JavaScript 中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error新类型：Symbol 2、Ajax使用全称 ： Asynchronous Javascript And XML所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。创建Ajax的过程：1) 创建XMLHttpRequest对象（异步调用对象） 1var xhr = new XMLHttpRequest(); 2) 创建新的Http请求（方法、URL、是否异步） 1xhr.open(‘get’,’example.php’,false); 3) 设置响应HTTP请求状态变化的函数。onreadystatechange事件中readyState属性等于4。响应的HTTP状态为200(OK)或者304(Not Modified)。4) 发送http请求 1xhr.send(data); 5) 获取异步调用返回的数据注意：1) 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互。2) 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。3) 尽量减少ajax请求次数4) ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。 3、JavaScript有几种类型的值 画一下他们的内存图 基本数据类型存储在栈中，引用数据类型（对象）存储在堆中，指针放在栈中。 两种类型的区别是：存储位置不同；原始数据类型直接存储在栈中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 4、 什么是window对象? 什么是document对象?window对象代表浏览器中打开的一个窗口。document对象代表整个html文档。实际上，document对象是window对象的一个属性。 5、 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？IE为事件冒泡，Firefox同时支持事件捕获和事件冒泡。但并非所有浏览器都支持事件捕获。jQuery中使用event.stopPropagation()方法可阻止冒泡;（旧IE的方法 ev.cancelBubble = true;） 6、 什么是闭包（closure），为什么要用它？闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。注意，闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的最后一个值。优点：避免全局变量污染。缺点：容易造成内存泄漏。例子： 123456789function makeFunc() &#123; var name = &quot;Mozilla&quot;; function displayName() &#123; console.log(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); //输出Mozilla myFunc 变成一个 闭包。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc 是一个闭包，由 displayName 函数和闭包创建时存在的 “Mozilla” 字符串形成。 7 、对JSON的了解？全称：JavaScript Object NotationJSON中对象通过“{}”来标识，一个“{}”代表一个对象，如{“AreaId”:”123”}，对象的值是键值对的形式（key：value）。JSON是JS的一个严格的子集，一种轻量级的数据交换格式，类似于xml。数据格式简单，易于读写，占用带宽小。 两个函数：JSON.parse(str)解析JSON字符串 把JSON字符串变成JavaScript值或对象 JSON.stringify(obj)将一个JavaScript值(对象或者数组)转换为一个 JSON字符串 eval(‘(‘＋json＋’)’)用eval方法注意加括号 而且这种方式更容易被攻击 8、documen.write和 innerHTML的区别document.write()只能重绘整个页面 123setTimeout(function()&#123; document.write(&apos;&lt;p&gt;5 secs later&lt;/p&gt;&apos;);&#125;, 5000); 或 1window.onload = function() &#123; document.write(&quot;HI&quot;); innerHTML可以重绘页面的一部分 9、DOM操作（1）创建新节点createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点（2）添加、移除、替换、插入appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点（3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 10、数组对象有哪些原生方法，列举一下pop、push、shift、unshift、splice、reverse、sort、concat、join、slice、toString、indexOf、lastIndexOf、reduce、reduceRightforEach、map、filter、every、some 11、那些操作会造成内存泄漏全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用 12、响应事件onclick鼠标点击某个对象；onfocus获取焦点；onblur失去焦点；onmousedown鼠标被按下]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO2！]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端面试基础一、CSS1、css盒模型 w3c盒子模型：属性width,height只包含内容content，不包含border和padding 属性width,height包含border和padding，指的是content+padding+border 2、居中布局水平居中元素： 通用方法，元素的宽高未知 方式一：CSS3 transform 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; left: 50%; transform: translateX(-50%);&#125; 方式二：Flex 布局 1234.parent &#123; display: flex; justify-content: center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可水平居中。 居中的元素为常规文档流中的内联元素(display: inline) 常见的内联元素有：span, a, img, input, label 等等 123.parent &#123; text-align: center;&#125; 此方法同样适用于 display: inline-block 的元素。 居中的元素为常规文档流中的块元素(display: block) 常见的块元素：div, h1~h6, table, p, ul, li 等等 方式一：设置 margin 123456789.parent &#123; width: 100%;&#125;.child &#123; width: 600px; height: 50px; margin: 0 auto; background: #999;&#125; 此方法只能进行水平的居中，且对浮动元素或绝对定位元素无效。 方式二：修改为 inline-block 属性 123456.parent &#123; text-align: center;&#125;.child &#123; display: inline-block;&#125; 居中的元素为浮动元素 1234567.child &#123; width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;&#125; 居中的元素为绝对定位元素 方式一： 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 50%; margin-left: -50px;&#125; 方式二： 12345678910.parent &#123; position: relative;&#125;.child &#123; position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;&#125; 垂直居中元素： 通用方法，元素的宽高未知 方式一：CSS3 transform 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 方式二：Flex 布局 1234.parent &#123; display: flex; align-items: center;&#125; 适用于子元素为浮动，绝对定位，内联元素，均可垂直居中。 居中元素为单行文本 1234.text &#123; line-height: 200px; height: 200px;&#125; 把文字的 line-height 设为文字父容器的高度，适用于只有一行文字的情况。 已知元素宽高 方式一： 123456789.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 50%; height: 100px; margin-top: -50px;&#125; 方式二： 12345678910.parent &#123; position: relative;&#125;.child&#123; position: absolute; top: 0; bottom: 0; height: 100px; margin: auto 0;&#125; 垂直居中元素： 1. 绝对居中定位 1234567891011div &#123; width: 100px; height: 100px; margin: auto; position: fixed; //absolute is ok top: 0; right: 0; bottom: 0; left: 0;&#125; 优点： 不仅可以实现在正中间，还可以在正左方，正右方 元素的宽高支持百分比 % 属性值和 min-/max- 属性 可以封装为一个公共类，可做弹出层 浏览器支持性好 2. 负边距居中 123456789.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px;&#125; 特点： 良好的跨浏览器特性,兼容 IE6 - IE7 灵活性差，不能自适应，宽高不支持百分比尺寸和 min-/max- 属性 3. Transform 定位 12345678.child &#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 特点： 内容可自适应，可以封装为一个公共类，可做弹出层 可能干扰其他 transform 效果 4. Flexbox 布局 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 这是 CSS 布局未来的趋势。Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。 5. table-cell 居中 1234567891011121314.parent &#123; display: table-cell; vertical-align: middle; text-align: center; width: 200px; height: 200px; border: 1px solid red;&#125;.child &#123; width: 100px; height: 100px; display: inline-block; background-color: #03f;&#125; 适用于子元素 display 为 inline-block, inline 类型的元素，需要已知父元素的宽高，且父元素的宽高不能设为百分比数。 6. font-size 配合 vertical-align 实现垂直居中 1234567891011121314.parent &#123; font-size: 175.4px; height: 200px; text-align: center;&#125;.child &#123; vertical-align: middle; display: inline-block; font-size: 12px; width: 50px; height: 50px; background-color: #00f;&#125; 该方法的要点是给父元素设一个合适的 font-size 的值，这个值的取值为该父元素的高度除以 1.14 得到的值，并且子元素必须 是一个 inline 或 inline-block 元素，需要加上 vertical-align: middle 属性。使用这种方法，子元素的宽度或高度都不必知道。 具体原理可以上网搜 vertical-align 垂直居中。 7. 文本内容**居中** 12345text &#123; height: 100px; line-height: 100px; text-align: center;&#125; 3、清除浮动分析HTML结构： 12345&lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt;&lt;/div&gt; 分析CSS代码样式： 12345678910111213141516171819202122232425.box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px; &#125; .div1 &#123; width: 100px; height: 100px; background: darkblue; float: left; &#125; .div2 &#123; width: 100px; height: 100px; background: darkgoldenrod; float: left; &#125; .div3 &#123; width: 100px; height: 100px; background: darkgreen; float: left; &#125; 什么是浮动 浮动：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来 一：添加新元素，应用clear：both;HTML： 123456&lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt; CSS： 12345.clear &#123; clear: both; height: 0; line-height: 0; font-size: 0 &#125; 二：父级div定义overflow：auto;HTML: 12345&lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt;&lt;/div&gt; CSS： 123456789.box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px; overflow: auto; zoom: 1; /*zoom: 1; 是在处理兼容性问题 */&#125; 三：在父级样式添加伪元素:after或者:before（推荐）HTML: 12345html &lt;div class="box"&gt; &lt;div class="div1"&gt;1&lt;/div&gt; &lt;div class="div2"&gt;2&lt;/div&gt; &lt;div class="div3"&gt;3&lt;/div&gt; &lt;/div&gt; CSS: 123456789101112 .box &#123; border: 1px solid #ccc; background: #fc9; color: #fff; margin: 50px auto; padding: 50px;&#125;.box:after&#123; content: ''; display: block; clear: both;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP相关面试题总结！]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%89%8D%E7%AB%AFhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP相关面试题总结1231、HTTP中常用的请求方法有哪些？哪些请求方法是安全的？为什么？答：常用的请求方法有GET,POST,HEAD,PUT,DELETE。其中GET和HEAD是安全的，因为其他的三个方法都会对服务器产生动作，GET和HEAD只是请求数据，POST和POUT都会给服务端发送报文主体 123456782、HTTP中POST和GET方法有什么区别？答：主要有以下几点区别：GET请求在页面后退的时候是无害的（即不会再次发送请求），而POST会再次发送请求GET请求的参数是放在请求的URL中，而POST方法是放在请求体中GET请求在URL中传递参数时会有长度限制，而POST无限制（不是绝对的，只是相对来说）GET请求会被浏览器主动缓存，而POST不会GET请求的参数会保存在浏览器中，而POST的参数不会保存在浏览器中 12345678910113、在浏览器中输入URL到页面进行渲染的过程中发生了什么？答：可以参考下面这张图理解：（参考《HTTP权威指南》） 浏览器解析主机名 DNS进行域名解析，即将语义化的主机名转换成IP地址 浏览器获得端口号 浏览器根据得到的ip地址和端口号发起TCP连接 浏览器发起HTTP请求 浏览器读取服务器返回的响应报文 浏览器对返回的HTML进行渲染 浏览器断开TCP连接 123456789101112131415161718194、请简单描述一下TCP的三次握手和四次挥手的过程，两次握手可以吗？答：详细解答 TCP的三次握手：a.客户端发送一个SYN报文请求连接，变为SYN_SEND状态b.服务端接收到客户端发送SYN包，进行确认过后，发送ACK报文，变为SYN_RECV状态c.客户端接收到服务端的SYN和ACK报文后，发送ACK包进行确认，然后客户端和服务端都变成ESTABLISHED状态 TCP的四次挥手：a.客户端没有数据要发送了，请求关闭连接，发送一个FIN报文，并进入FIN_WAIT_1状态b.服务端接收到FIN报文后，发送ACK报文，然后进入CLOSE_WAIT状态；客户端接收到ACK报文后，进入FIN_WAIT_2状态c.服务端判断是否有数据发送给客户端，如果有的话，就将数据发送给客户端，再发送FIN报文；没有的话就直接发送FIN报文，请求关闭连接，然后进入LAST_ACK状态；d.客户端接收到服务端的FIN报文后，发送ACK报文，然后客户端进入TIME_WAIT状态；服务端接收到ACK报文后，关闭连接，变为CLOSED状态，客户端在2MSL后依然没有收到回复，也可以关闭连接了。 两次握手可以吗？ 不可以，三次握手主要是防止已经过期的请求再次连接到服务端而占用资源造成浪费。如果是两次握手的话，假设主机A在发送第一次请求时，由于网络滞留的问题卡住了，很久后没有收到主机B的确认信息，于是又发送了第二次请求。过了一段时间后，第一个请求到达了主机B，主机B以为是一次新的请求，就返回确认信息，但是由于没有第三次握手，只要主机B发出确认信息，就会连接，这个时候主机B一直等待着主机A发送信息，就会造成资源浪费。 123456789105、TCP和UDP的区别是什么？答：主要有以下几个方面的区别：a.连接方面：TCP是面向连接的，而UDP是无连接的，即UDP在传输数据之前不需要像TCP那样3次握手建立连接b.可靠性：TCP比UDP更可靠，TCP可以保证不丢包，会按照顺序传输数据，这也是导致c.资源消耗：TCP对系统资源要求比较高，并且消耗资源比较大；UDP要求不高，但是在网络质量不好的情况下比较容易丢包，消耗资源相对比较小d.适用场景：TCP适用于HTTP，FTP以及邮件传输等等；而UDP比较适合于语音，视频等e.速度问题：TCP传输速度比较慢，效率低，在握手和挥手的过程中会占用很多时间；UDP传输速度比较快，由于是无连接的，只有传输数据的过程f.安全性：安全性和可靠性是不同的概念，由于TCP的机制比较多，更容易受到攻击；UDP相对来说就比较安全，但是也不能避免受到攻击g.连接形式：TCP是只能一对一的发送，而UDP可以是一对一，一对多，多对多 1234567896、HTTP中常见的状态码有哪些？分别表示什么意思？答：常见的状态码有：200：接收并响应成功301：请求的资源已经换了URL，需要重新请求（永久重定向）302：请求的资源临时换了URL，需要重新请求（临时重定向）304：在缓存中有该资源，可以直接获取403：该资源禁止访问404：该资源不存在 123456789101112131415167、HTTP有什么特点？HTTP有什么缺点？答：特点 * 简单高效 * 灵活 * 无连接 * 无状态答：有以下缺点： * 一条连接上只能发送一个请求 * 请求只能从客户端开始，客户端不可以接收除响应之外的指令 * 请求/响应首部未经压缩就发送，首部信息越多造成的延迟越大 * 发送冗长的首部，每次互发相同的首部造成很大的浪费 * 通信使用明文，内容可能会被窃听 * 不验证通信方的身份，有可能会遭遇伪装 * 无法验证报文的完整性，有可能遭遇篡改 123456788、请描述AJAX实现原理答：AJAX的实现核心在于XMLHttpRequest这个API，主要分为以下几个步骤（参考文章：https://segmentfault.com/a/1190000017176090）：创建XMLHttpRequst对象初始化传进来的参数使用open方法发送请求接收请求并调用onreadystatechange方法对返回成功以及失败的情况进行定义 123456789101112139、HTTP和HTTPS的关系以及HTTPS的实现原理答：* HTTPS和HTTP的关系 HTTPS在HTTP的基础上加上了SSL协议，使得HTTP通信更加安全。针对HTTP无法验证通信方的身份，无法验证报文的完整性以及容易被窃听等安全方面的缺点，HTTPS添加了加密和认证机制，使得HTTP通信更加安全。* HTTPS通信原理（加密机制，不包括认证机制以及验证报文完整性机制，可参考这里） 1.客户端发送请求 2.服务端接收请求返回数字证书 3.客户端使用内置的CA解密证书，拿到公钥 4.如果证书没有问题，就将自己的对称秘钥使用公钥加密发送给服务端 5.服务端使用私钥进行解密 6.客户端和服务端使用对称秘钥进行通信 1234567891010、webScoket是什么？主要作用是什么？ 答：webScoket也是一种协议，用来解决要实现实时更新时，只能通过AJAX轮询等方式的问题。使用这个协议就改变了只能客户端发送请求，服务端接收请求的模式，在该协议中客户端和服务端都可以发送请求和接收请求，从而实现实时推送（服务端有数据更新后就发送数据）的功能，基于该协议可以大大的减少通信量。11、SSL有几次握手？具体过程是怎样的？答：这个问题和HTTPS的实现原理可以看做是一样的，但是比较有针对性，以下是回答： SSL有4次握手，握手过程为： 1.客户端请求SSL连接 2.服务端发送包含公钥的证书 3.客户端使用公钥加密对称秘钥并发送给服务端 4.服务端使用私钥解密对称秘钥 文章来源：https://segmentfault.com/a/1190000017322866]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题基础NO1！]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80No1%2F</url>
    <content type="text"><![CDATA[前端基础面试题总结1、HTML5新特性HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 2、关于SEO性能优化（1） 减少http请求次数：CSS Sprites， JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的浏览器中 3、怎样理解语义化html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 4、怎么实现跨域，jsonp跨域原理，cors跨域需要设置什么？ 跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 （1）script标签jsonp跨域； （2）nginx反向代理； （3）node.js中间代理跨域； （4）后端在头部信息设置安全域名； （5）后端在服务器上设置cors。 jsonp跨域原理：首先在客户端注册一个callback，然后把callback的名字传给服务器，服务器生成json数据，然后以JavaScript语法生成一个function，function名字就是传递上来的参数jsonp，最后将json数据直接以参数方式放置到function中，生成js文档，返回给客户端，客户端浏览器解析script标签，并执行返回的JavaScript文档，此时数据作为参数，传入到客户端预先定义好的callback函数里（动态执行回调函数） cors跨域需要设置头部Access-Control-Allow-Origin 参数 5、谈一谈对this的理解通常情况下，this指向的是执行上下文中当前的对象；在事件函数中，this通常指向的是事件源DOM元素对象；在构造函数中，this通常指向其new所创建的对象本身。 如何绑定this 可以使用call（）、apply（）绑定使用Function.prototype.bind()进行绑定使用new关键字进行绑定 6、call（）、apply（）、bind（）区别apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为：fun.call(thisArg[, arg1[, arg2[, …]]])apply的语法为：fun.apply(thisArg, [argsArray]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用 7、CSS3新增这里可以分为边框、背景，渐变，阴影、2D转换 3D转换等之类的来说。比如：边框(border-radius、border-shadow、border-image)之类的 8、vue数据双向绑定利用object.defineproperty()这个方法重新定义了对象获取属性值（get）和设置属性值（set）的操作来实现的。 9、前端路由通常 SPA 中前端路由有2种实现方式：window.historylocation.hash 10、let const var有什么区别？let是块级作用域，函数内部使用let定义后，对函数外部无影响。 const定义的变量不可以修改，而且必须初始化。const b = 2;//正确 // const b;//错误，必须初始化 console.log(‘函数外const定义b：’ + b);//有输出值 // b = 5;5 // console.log(‘函数外修改const定义b：’ + b);//无法输出 var定义的变量可以修改，如果不初始化会输出undefined，不会报错。 文章来源：https://juejin.im/post/5ac87838f265da237314b389]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS一些面试题]]></title>
    <url>%2F2019%2F04%2F06%2FJS%20%E8%83%BD%E5%8A%9B%E6%B5%8B%E8%AF%84%E7%BB%8F%E5%85%B8%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、数组模块：1、找出元素 item 在给定数组 arr 中的位置1如果数组中存在 item，则返回元素在数组中的位置，否则返回 -1 示例1 输入 [ 1, 2, 3, 4 ], 3 输出 2 123function indexOf(arr, item) &#123; return arr.indexOf(item);&#125; 2、数组求和计算给定数组 arr 中所有元素的总和：数组中的元素均为 Number 类型 input [ 1, 2, 3, 4 ] output 10 12345678910111213141516171819202122232425262728293031323334353637不考虑算法复杂度，用递归做：function sum(arr) &#123; var len = arr.length; if(len == 0)&#123; return 0; &#125; else if (len == 1)&#123; return arr[0]; &#125; else &#123; return arr[0] + sum(arr.slice(1)); &#125;&#125;常规循环：function sum(arr) &#123; var s = 0; for (var i=arr.length-1; i&gt;=0; i--) &#123; s += arr[i]; &#125; return s;&#125;函数式编程 map-reduce：function sum(arr) &#123; return arr.reduce(function(prev, curr, idx, arr)&#123; return prev + curr; &#125;);&#125;forEach遍历：function sum(arr) &#123; var s = 0; arr.forEach(function(e) &#123; s += e; &#125;) return s;&#125;;eval：function sum(arr) &#123; return eval(arr.join("+"));&#125;; 3、移除数组中的元素移除数组 arr 中的所有值与 item 相等的元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4, 2], 2 输出 [1, 3, 4] 123456789101112function remove(arr, item) &#123; //声明一个新数组保存结果 var a = []; //循环遍历 for(var i=0; i &lt; arr.length; i++)&#123; //如果arr[i]不等于item，就加入数组a if(arr[i] != item)&#123; a.push(arr[i]); &#125; &#125; return a; &#125; 移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回 输入 [1, 2, 2, 3, 4, 2, 2], 2 输出 [1, 3, 4] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function removeWithoutCopy(arr, item) &#123; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i] == item)&#123; arr.splice(i,1);//从数组的第i个位置开始，删除后一个元素 i--;//因为他是直接删除的，那个下标会改变的,所以要自减 &#125; &#125; return arr&#125; removeWithoutCopy([1, 2, 2, 4, 2, 2], 2);1.splice()function remove(arr,item)&#123; for(var i=0;i&lt;newarr.length;i++)&#123; if(newarr[i] == item)&#123; newarr.splice(i,1)； &#125; &#125; return newarr;&#125; 2.push()function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] != item)&#123; newarr.push(arr[i]); &#125; &#125; return newarr;&#125;function remove(arr,item)&#123; var newarr = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i] == item)continue; newarr.push(arr[i]); &#125; return nawarr;&#125;3.Arra y.prototype.filter()function remove(arr,item)&#123; return arr.filter(function(ele)&#123; return ele != item; &#125;)&#125; 4、 添加元素在数组 arr 末尾添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], 10 输出 [1, 2, 3, 4, 10] 123456789function append(arr, item) &#123; var a=[]; for(var i=0;i&lt;arr.length;i++)&#123; a.push(arr[i]); &#125; a.push(item); return a;&#125;append([1, 2, 3, 4], 10); 在数组 arr 的 index 处添加元素 item。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], ‘z’, 2 输出 [1, 2, ‘z’, 3, 4] 1234567891011121314151617181920212223242526272829303132//利用slice+concatfunction insert(arr, item, index) &#123; return arr.slice(0,index).concat(item,arr.slice(index));&#125;//利用concat +splicefunction insert(arr, item, index) &#123; var newArr=arr.concat(); newArr.splice(index,0,item); return newArr;&#125;//利用slice+splicefunction insert(arr, item, index) &#123; var newArr=arr.slice(0); newArr.splice(index,0,item); return newArr;&#125;//利用push.apply+splicefunction insert(arr, item, index) &#123; var newArr=[]; [].push.apply(newArr, arr); newArr.splice(index,0,item); return newArr;&#125;//普通的迭代拷贝function insert(arr, item, index) &#123; var newArr=[]; for(var i=0;i&lt;arr.length;i++)&#123; newArr.push(arr[i]); &#125; newArr.splice(index,0,item); return newArr;&#125; 5、删除数组最后一个元素删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 2, 3] 123456function truncate(arr) &#123; var newArr=arr.slice(0)//slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。//语法 stringObject.slice(start,end) newArr.pop()//pop() 方法用于删除并返回数组的最后一个元素。 return newArr&#125; 6.删除数组第一个元素删除数组 arr 第一个元素。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [2, 3, 4] 12345function curtail(arr) &#123; var a = arr.slice(0) a.shift() return a&#125; 7、数组合并合并数组 arr1 和数组 arr2。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4], [‘a’, ‘b’, ‘c’, 1] 输出 [1, 2, 3, 4, ‘a’, ‘b’, ‘c’, 1] 1234567891011121314151617181920212223242526272829//利用concatfunction concat(arr1, arr2) &#123; return arr1.concat(arr2);&#125;//利用slice+push.applyfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); [].push.apply(newArr, arr2); return newArr;&#125;//利用slice+pushfunction concat(arr1, arr2) &#123; var newArr=arr1.slice(0); for(var i=0;i&lt;arr2.length;i++)&#123; newArr.push(arr2[i]); &#125; return newArr;&#125;//普通的迭代拷贝function concat(arr1, arr2) &#123; var newArr=[]; for(var i=0;i&lt;arr1.length;i++)&#123; newArr.push(arr1[i]); &#125; for(var j=0;j&lt;arr2.length;j++)&#123; newArr.push(arr2[j]); &#125; return newArr;&#125; 8、计数统计数组 arr 中值等于 item 的元素出现的次数 输入 [1, 2, 4, 4, 3, 4, 3], 4 输出 3 12345678910111213141516171819202122232425262728293031323334353637383940414243//filter()--&gt;利用指定的函数确定是否在返回的数组中包含某一项 function count(arr, item) &#123; var count = arr.filter(function(a) &#123; return a === item; //返回true的项组成的数组 &#125;); return count.length; &#125; //map()--&gt;对数组中的每一项进行给定函数， //返回每次函数条用的结果组成的数组； function count(arr, item) &#123; var count = 0; arr.map(function(a) &#123; if(a === item) &#123; count++; &#125; &#125;); return count; &#125; //for循环 function count(arr, item) &#123; var count = 0; for(var i=0; i&lt;arr.length; i++) &#123; if(arr[i] === item) &#123; count++; &#125; &#125; return count; &#125; //reduce()--&gt;从数组的第一项开始，逐个遍历到最后； function count(arr, item) &#123; var count = arr.reduce(function(prev, curr) &#123; return curr === item ? prev+1 : prev; &#125;, 0); return count; &#125; //forEach()--&gt;对数组中的每一项运行传入的函数 function count(arr, item) &#123; var count = 0; arr.forEach(function(a) &#123; a === item ? count++ : 0; &#125;); return count; &#125; 9、查找重复元素找出数组 arr 中重复出现过的元素 输入 [1, 2, 4, 4, 3, 3, 1, 5, 3] 输出 [1, 3, 4] 12345678function duplicates(arr) &#123; var a=arr.sort(),b=[]; for(var i in a)&#123; if(a[i]==a[i-1] &amp;&amp; b.indexOf(a[i])==-1) b.push(a[i]); &#125; return b;&#125;//先排序，如果后一个与前一个相等且未保存，则保存。 10、 求二次方为数组 arr 中的每个元素求二次方。不要直接修改数组 arr，结果返回新的数组 输入 [1, 2, 3, 4] 输出 [1, 4, 9, 16] 12345678910111213141516171819202122232425262728293031323334// 1function square(arr) &#123; var a = arr.slice(0) a = a.map(function(val) &#123; return val*val &#125;) return a&#125;function square(arr) &#123; var newarr = arr.slice(0); //复制一个arr数组 for (var i=0;i&lt;newarr.length;i++)&#123; newarr[i]= newarr[i]* newarr[i]; &#125; return newarr;&#125;// 2function square(arr) &#123; return arr.map(function(item,index,array)&#123; return item*item; &#125;)&#125;//3function square(arr) &#123; //声明一个新的数组存放结果 var a = []; arr.forEach(function(e)&#123; //将arr中的每一个元素求平方后，加入到a数组中 a.push(e*e); &#125;); return a; &#125; 11、查找元素位置在数组 arr 中，查找值与 item 相等的元素出现的所有位置 输入 ‘abcdefabc’ 输出 [0, 6] 12345678910111213141516171819202122232425262728293031323334353637//filterfunction findAllOccurrences(arr, target) &#123; var result=[]; arr.filter(function(item,index)&#123; return item===target&amp;&amp;result.push(index); &#125;); return result;&#125;//forfunction findAllOccurrences(arr, target) &#123; var result=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]===target)&#123; result.push(i); &#125; &#125; return result;&#125;//lastIndexOf+slice/splicefunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.lastIndexOf(target); while(index&gt;-1)&#123; result.push(index); arr.splice(index,1);//arr=arr.slice(0,index); index=arr.lastIndexOf(target); &#125; return result;&#125;//indexOffunction findAllOccurrences(arr, target) &#123; var result=[],index=arr.indexOf(target); while(index&gt;-1)&#123; result.push(index); index=arr.indexOf(target,index+1); &#125; return result;&#125; 二、函数部分 ：1、避免全局变量1234567function globals() &#123; var myObject = &#123; //这里需要加 var let等关键字 name : 'Jory' &#125;; return myObject;&#125; 2、正确的定义函数请修复给定的 js 代码中，函数定义存在的问题 输入 true 输出 a 123456789101112131415161718192021222324//源码function functions(flag) &#123; if (flag) &#123; function getValue() &#123; return 'a'; &#125; &#125; else &#123; function getValue() &#123; return 'b'; &#125; &#125; return getValue();&#125;// 改正后的function functions(flag) &#123; if (flag) &#123; var getValue =function() &#123; return 'a'; &#125; &#125; else &#123; var getValue =function() &#123; return 'b'; &#125; &#125; return getValue();&#125;functions(true); 3、判断两个数是否相等判断 val1 和 val2 是否完全等同 12345678910111213141516171819202122232425262728293031323334function identity(val1, val2) &#123; if(val1===val2) &#123; return true; &#125;else&#123; return false &#125;&#125;// 以后就简写装逼function identity(val1, val2) &#123; if(val1===val2)return true; else return false;&#125;/* 一般使用双等来判断（==），如果还需要类型相同那么就用三等（===）。说一下这两个的区别：== equality 等同，=== identity 恒等。==， 两边值类型不同的时候，要先进行类型转换，再比较。 ==，不做类型转换，类型不同的一定不等。 下面分别说明： 先说 ===，这个比较简单。下面的规则用来判断两个值是否===相等： 1、如果类型不同，就[不相等] 2、如果两个都是数值，并且是同一个值，那么[相等]。3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 4、如果两个值都是true，或者都是false，那么[相等]。 5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 6、如果两个值都是null，或者都是undefined，那么[相等]。 再说 ==，根据以下规则： 1、如果两个值类型相同，进行 === 比较。 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么[相等]。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 d、任何其他组合，都[不相等]。*/ 4、计时器实现一个打点计时器，要求1、从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 12、返回的对象中需要包含一个 cancel 方法，用于停止定时操作3、第一个数需要立即输出 1234567891011121314151617function count(start, end) &#123; //立即输出第一个值 console.log(start++); var timer = setInterval(function()&#123; if(start &lt;= end)&#123; console.log(start++); &#125;else&#123; clearInterval(timer); &#125; &#125;,100); //返回一个对象 return &#123; cancel : function()&#123; clearInterval(timer); &#125; &#125;; &#125; 5、流程控制实现 fizzBuzz 函数，参数 num 与返回值的关系如下：1、如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz2、如果 num 能被 3 整除，返回字符串 fizz3、如果 num 能被 5 整除，返回字符串 buzz4、如果参数为空或者不是 Number 类型，返回 false5、其余情况，返回参数 num 输入: 15 输出： fizzbuzz 12345678910111213141516171819202122232425262728function fizzBuzz(num) &#123; if(num%3 == 0 &amp;&amp; num%5 == 0) return "fizzbuzz"; else if(num%3 == 0) return "fizz"; else if(num%5 == 0) return "buzz"; else if(num == null || typeof num != "number") return false; else return num;&#125;//又一方法function fizzBuzz(num) &#123; var a = num % 3; var b = num % 5; if (a == 0 &amp;&amp; b == 0) &#123; return 'fizzbuzz'; &#125; else if (a == 0) &#123; return 'fizz' &#125; else if (b == 0) &#123; return 'buzz' &#125; else if (num == 'null' || typeof (num) != 'number') &#123; return false &#125; else &#123; return num &#125;&#125; 6、 函数传参将数组 arr 中的元素作为调用函数 fn 的参数 输入：function (greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }, [‘Hello’, ‘Ellie’, ‘!’] 输出：Hello, Ellie! 123456789//调用函数可以使用call或者apply这两个方法，区别在于call需要将传递给函数的参数明确写出来，是多少参数就需要写多少参数。而apply则将传递给函数的参数放入一个数组中，传入参数数组即可。function argsAsArray(fn, arr) &#123; return fn.apply(this, arr)&#125;// 调用函数的三种方式obj.func();func.call(obj,args);//参数列出func.apply(obj,[m,n......]);//参数数组 7、函数的上下文将函数 fn 的执行上下文改为 obj 对象 输入：function () {return this.greeting + ‘, ‘ + this.name + ‘!!!’;}, {greeting: ‘Hello’, name: ‘Rebecca’} 输出：Hello, Rebecca!!! 123456//在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function speak(fn, obj) &#123; return fn.apply(obj, obj); &#125; 8、返回函数实现函数 functionFunction，调用之后满足如下条件：1、返回值为一个函数 f2、调用返回的函数 f，返回值为按照调用顺序的参数拼接，拼接字符为英文逗号加一个空格，即 ‘, ‘3、所有函数的参数数量为 1，且均为 String 类型 输入：functionFunction(‘Hello’)(‘world’) 输出：Hello, world 12345678//首先执行functionFunction('Hello')，传入参数str，然后返回函数f，f与('world')组合，执行f('world')，传入参数s，f返回str+", "+s，即Hello, world。注意中间的逗号后面有一个空格。function functionFunction(str) &#123; var f = function(s)&#123; return str+", "+s; &#125; return f; &#125; 9、使用闭包实现函数 makeClosures，调用之后满足如下条件：1、返回一个函数数组 result，长度与 arr 相同2、运行 result 中第 i 个函数，即 resulti，结果与 fn(arr[i]) 相同 输入：[1, 2, 3], function (x) {​ return x * x;} 输出：4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function makeClosures(arr, fn) &#123; var result = []; arr.forEach(function (obj) &#123; result.push(function () &#123; return fn(obj); &#125;) &#125;); return result;&#125;//es6的function makeClosures(arr, fn) &#123; var result = new Array(); for(let i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); //let声明的变量只在let所在代码块内有效，因此每次循环的i都是一个新的变量 &#125;; &#125; return result;&#125;//es5的//这种是错误的写法会导致result中每个函数的参数都是arr[arr.length]function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function()&#123; return fn(arr[i]); &#125;; &#125; return result;&#125;//参考《JavaScript高级程序设计》的典型方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = function(num)&#123; return function()&#123; return fn(num); &#125; &#125;(arr[i]); &#125; return result;&#125;//使用ES5的bind()方法function makeClosures(arr, fn) &#123; var result = new Array(); for(var i=0;i&lt;arr.length;i++)&#123; result[i] = fn.bind(null,arr[i]); &#125; return result;&#125;//使用forEach()function makeClosures(arr, fn) &#123; var result = new Array(); arr.forEach(function(curr)&#123; result.push(function()&#123;return fn(curr)&#125;); &#125;) return result;&#125; 10、二次封装函数已知函数 fn 执行需要 3 个参数。请实现函数 partial，调用之后满足如下条件：1、返回一个函数 result，该函数接受一个参数2、执行 result(str3) ，返回的结果与 fn(str1, str2, str3) 一致 输入：var sayIt = function(greeting, name, punctuation) { return greeting + ‘, ‘ + name + (punctuation || ‘!’); }; partial(sayIt, ‘Hello’, ‘Ellie’)(‘!!!’); 输出：Hello, Ellie!!! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// call和apply必须显式地调用str3，立即执行// bind不是立即执行，未传入str3时，并未执行，只是返回一个函数，等待参数传入// this用于上下文不确定的情况 // callfunction partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.call(this, str1, str2, str3); &#125; return result;&#125; // apply（这里只是为了对照）function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.apply(this, [str1, str2, str3]); &#125; return result;&#125; // 这个bind会生成一个新函数（对象）, 它的str1, str2参数都定死了, str3未传入, 一旦传入就会执行function partial(fn, str1, str2) &#123; return fn.bind(this, str1, str2); // 或 return fn.bind(null, str1, str2);&#125; // bind同上, 多了一步, 把str3传入的过程写在另一个函数里面,// 而另一个函数也有str1, str2参数// 此法有种多次一举的感觉，但是表示出了后续的调用。function partial(fn, str1, str2) &#123; function result(str3) &#123; return fn.bind(this, str1, str2)(str3); &#125; return result;&#125; // 匿名函数，默认this绑定global，与bind的第一个参数为this时效果一样。function partial(fn, str1, str2) &#123; return function(str3) &#123; return fn(str1, str2, str3); &#125;&#125; // ES6。this指向undefined.const partial = (fn, str1, str2) =&gt; str3 =&gt; fn(str1, str2, str3); 实现函数 partialUsingArguments，调用之后满足如下条件：1、返回一个函数 result2、调用 result 之后，返回的结果与调用函数 fn 的结果一致3、fn 的调用参数为 partialUsingArguments 的第一个参数之后的全部参数以及 result 的调用参数 输入：无 输出：无 123456789101112// ****类似与11题*****//arguments不能用slice方法直接截取，需要先转换为数组，var args = Array.prototype.slice.call(arguments);合并参数可以使用concat方法，并且也需要将arguments先转换为数组才能使用concat进行合并。最用使用apply执行传入的函数即可。function partialUsingArguments(fn) &#123; //先获取p函数第一个参数之后的全部参数 var args = Array.prototype.slice.call(arguments,1); //声明result函数 var result = function()&#123; //使用concat合并两个或多个数组中的元素 return fn.apply(null, args.concat([].slice.call(arguments))); &#125; return result; &#125; 11、使用arguments函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。 输入：1, 2, 3, 4 输出：10 1234567891011121314function useArguments() &#123; /* 因为参数数量不定，可以先获取参数个数arguments.length 然后循环求值 */ //声明一个变量保存最终结果 var sum = 0; //循环求值 for(var i = 0; i &lt; arguments.length; i++)&#123; sum += arguments[i]; &#125; return sum; &#125;console.log(useArguments(1,2,3,4));//output 10 12、使用apply 调用函数实现函数 callIt，调用之后满足如下条件1、返回的结果为调用 fn 之后的结果2、fn 的调用参数为 callIt 的第一个参数之后的全部参数 输入：无 输出：无 12345678910//因为arguments并非真正的数组，因此要获得callIt的第一个参数之后的所有参数，不能直接使用slice方法截取，需要先将arguments转换为真正的数组才行。有两种常见的方法，一是使用slice方法：var args = Array . prototype . slice . call ( arguments );二是循环遍历逐一填入新数组。在获得了args之后，就可以调用apply来执行传入的函数参数。function callIt(fn) &#123; //将arguments转化为数组后，截取第一个元素之后的所有元素 var args = Array.prototype.slice.call(arguments,1); //调用fn var result = fn.apply(null,args);//因为调用calllt的第一个参数之后的全部参数，所以这里是null return result;&#125; 13、柯里化柯里化有3个常见作用： 1. 参数复用 ；2. 提前返回；3. 延迟计算/运行 已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：1、返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）2、调用 a 之后，返回一个函数 b, b 的 length 属性值为 13、调用 b 之后，返回一个函数 c, c 的 length 属性值为 14、调用 c 之后，返回的结果与调用 fn 的返回值一致5、fn 的参数依次为函数 a, b, c 的调用参数 输入：var fn = function (a, b, c) {return a + b + c}; ​ curryIt(fn)(1)(2)(3); 输出：6 123456789101112131415161718192021222324252627282930313233function curryIt(fn) &#123; return a = function(d)&#123; var b1 = arguments[0]; return b = function(f)&#123; var c1 = arguments[0]; return c = function(g)&#123; var a1 = arguments[0]; return fn.call(this,d,f,g); &#125; &#125; &#125;&#125;//柯里化是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。简单理解题目意思，就是指，我们将预定义的函数的参数逐一传入到curryIt中，当参数全部传入之后，就执行预定义函数。于是，我们首先要获得预定义函数的参数个数fn.length，然后声明一个空数组去存放这些参数。返回一个匿名函数接收参数并执行，当参数个数小于fn.length，则再次返回该匿名函数，继续接收参数并执行，直至参数个数等于fn.length。最后，调用apply执行预定义函数。function curryIt(fn) &#123; //获取fn参数的数量 var n = fn.length; //声明一个数组args var args = []; //返回一个匿名函数 return function(arg)&#123; //将curryIt后面括号中的参数放入数组 args.push(arg); //如果args中的参数个数小于fn函数的参数个数， //则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。 //否则，返回fn的调用结果 if(args.length &lt; n)&#123; return arguments.callee; &#125;else return fn.apply("",args); &#125; &#125; 三、逻辑运算：1、或运算返回参数 a 和 b 的逻辑或运算结果 输入：false, true 输出：true 1234function or(a, b) &#123; if(a||b) return true; else return false;&#125; 2、且运算返回参数a 和 b 的逻辑且运算结果 输入：false, true 输出： false 123functino add(a,b)&#123; return a&amp;&amp;b;&#125; 四、其它部分：1、模块完成函数 createModule，调用之后满足如下要求：1、返回一个对象2、对象的 greeting 属性值等于 str1， name 属性值等于 str23、对象存在一个 sayIt 方法，该方法返回的字符串为 greeting属性值 + ‘, ‘ + name属性值 12345678910111213声明对象有两种常见的方式：var obj = &#123;&#125;;和var obj = new Object();。前面一种可以直接在括号中以key:value的方式定义属性，后一种采用点运算符给对象添加属性。function createModule(str1, str2) &#123; var obj = &#123; greeting : str1, name : str2, sayIt : function()&#123; //两个属性前面都需要加上this return this.greeting+", "+this.name; &#125; &#125;; return obj; &#125; console.log(createModule("11","22"))//&#123;greeting: "11", name: "22", sayIt: ƒ&#125; 2、二进制转换获取数字 num 二进制形式第 bit 位的值。注意：1、bit 从 1 开始2、返回 0 或 13、举例：2 的二进制为 10，第 1 位为 0，第 2 位为 1 输入：128,8 输出：1 12345678910通过num.toString(2)能直接将num转换为2进制数格式的字符串，利用下标就能将对应值取出来。题目返回的数字是从右往左，因此下标为倒数。function valueAtBit(num, bit) &#123; var s = num.toString(2); console.log(s);//1000 0000 console.log(s.length)//8 return s[s.length - bit]; &#125; console.log(valueAtBit(128,8))//1 给定二进制字符串，将其换算成对应的十进制数字 输入：’11000000’ 输出：192 123456789101112parseInt方法可以将其它进制转换为十进制，只需要给该方法传入需要转换的字符串和该字符串的进制表示两个参数即可。function base10(str) &#123; /** 其它进制转十进制 parseInt(str,2) parseInt(str,8) parseInt(str,16) */ return parseInt(str,2);&#125;console.log(base10('11000000'))//192 将给定数字转换成二进制字符串。如果字符串长度不足 8 位，则在前面补 0 到满8位。 输入：65 输出：01000001 123456789101112131415161718192021function convertToBinary(num) &#123; var s = num.toString(2); while(s.length&lt;8)&#123; s = '0'+s; &#125; return s;&#125;//首先通过toString方法将num转为2进制数形式，然后判断其长度是否足够8位。如不足8位，则声明一个“0000000”字符串用于补0，因为目标的2进制数形式最少为一位，因此最多只需要7个0；通过slice方法对“0000000”进行截取，然后将其结果加在目标前面即可。function convertToBinary(num) &#123; //转换为2进制格式 var s = num.toString(2); //获得2进制数长度 if( s.length&lt;8)&#123; //声明一个字符串用于补满0 var s1 = "0000000"; var s2 = s1.slice(0,8-l); s = s2+s; &#125; return s; &#125; 3、乘法求 a 和 b 相乘的值，a 和 b 可能是小数，需要注意结果的精度问题 输入：3, 0.0001 输出：0.0003 1234567891011121314151617181920212223// 1 function multiply(a, b) &#123; return a*b*10000*10000/10000/10000&#125;// 2//根据两个书中精度较高的一个来确定，先将其转换成字符串，然后根据小数点的位置确定小数位数，//字符串长度减去‘.'的位置后还要再减去1得到正确的小数位数，两个取其大，然后用toFixed()函数确定 //结果的小数位数function multiply(a, b) &#123; //求两个数中精度大的一个 var stra=a.toString(); var strb=b.toString(); var len=Math.max(stra.length-stra.indexOf('.')-1,strb.length-strb.indexOf('.')-1); // return parseFloat(a*b).toFixed(len);&#125;// 3//通过将a、b小数位数的相加，能够得到a*b结果的小数位数最大可能值。然后使用toFixed方法可以将结果的小数位数指定为可能的最大值，即保证了结果的精度。但本题实际上，仅返回a*b也能通过。在浏览器上做实验，最大17位的小数位数满足了该题全部的测试用例。function multiply(a, b) &#123; return a*b; &#125; 4、改变上下文将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值 输入：alterContext(function() {return this.greeting + ‘, ‘ + this.name + ‘!’; }, {name: ‘Rebecca’, greeting: ‘Yo’ }) 输出：Yo, Rebecca! 12345678910111213141516//主要有三种答案。function alterContext(fn, obj) &#123; return fn.bind(obj)();//.bind()返回的是一个函数，所以需要立即执行。 &#125; function alterContext(fn, obj) &#123; return fn.call(obj);&#125; function alterContext(fn, obj) &#123; return fn.apply(obj);&#125; //在JavaScript中，函数是一种对象，其上下文是可以变化的，对应的，函数内的this也是可以变化的，函数可以作为一个对象的方法，也可以同时作为另一个对象的方法，可以通过Function对象中的call或者apply方法来修改函数的上下文，函数中的this指针将被替换为call或者apply的第一个参数。将函数 fn 的执行上下文改为 obj 对象，只需要将obj作为call或者apply的第一个参数传入即可。function alterContext(fn, obj) &#123; return fn.call(obj,obj); &#125; 5、批量改变对象属性 ( 涉及原型链问题 )给定一个构造函数 constructor，请完成 alterObjects 方法，将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量。 输入：var C = function(name) {this.name = name; return this;};var obj1 = new C(‘Rebecca’);alterObjects(C, ‘What\’s up’); obj1.greeting; 输出：What’s up 12345//这是原型链问题。访问一个对象的方法或者是属性，首先会在该对象中寻找，如果找到则返回，如果没找到，则在其原型链上面向上寻找，直至基原型，如还未找到，则返回undefined。将 constructor 的所有实例的 greeting 属性指向给定的 greeting 变量，只需要在constructor的原型上面添加greeting属性，并指定值。function alterObjects(constructor, greeting) &#123; //添加prototype的作用就是添加一个公共方法，或者公共属性 constructor.prototype.greeting = greeting; &#125; 6、属性遍历找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)1、返回数组，格式为 key: value2、结果数组不要求顺序 输入：var C = function() {this.foo = ‘bar’; this.baz = ‘bim’;};C.prototype.bop = ‘bip’;iterate(new C()); 输出：[“foo: bar”, “baz: bim”] 12345678910111213//可以使用for-in来遍历对象中的属性，hasOwnproperty方法能返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性，该属性必须为对象本身的属性。function iterate(obj) &#123; var arr = []; //使用for-in遍历对象属性 for(var key in obj)&#123; //判断key是否为对象本身的属性 if(obj.hasOwnProperty(key))&#123; //将属性和值按格式存入数组 arr.push(key+": "+obj[key]); &#125; &#125; return arr; &#125; 7、判断是否包含数字（涉及正则表达式）给定字符串 str，检查其是否包含数字，包含返回 true，否则返回 false 输入：’abc123’ 输出：true 1234567891011121314151617// 方法一//判断字符串中是否含有数字，可以用正则表达式。/\d/可以匹配字符串中的数字字符，用test方法可以检测。function containsNumber(str) &#123; var b = /\d/; return b.test(str); &#125;//方法二function containsNumber(str) &#123; for(var i=0 ; i&lt;str.length ; i++)&#123; if(str[i] &gt; '0' &amp;&amp; str[i] &lt; '9')&#123; return true; &#125; &#125; return false;&#125; 8、检查重复字符串(正则表达式)给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 输入：’rattler’ 输出：true 1234在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\1就是引用第一个分组，\2就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。function containsRepeatingLetter(str) return /([a-zA-Z])\1/.test(str); 9、判断是否以元音字母结尾（正则表达式）给定字符串 str，检查其是否以元音字母结尾1、元音字母包括 a，e，i，o，u，以及对应的大写2、包含返回 true，否则返回 false 输入：’gorilla’ 输出：true 12345//首先确定元音集合[a,e,i,o,u]，然后是以元音结尾，加上$，最后通配大小写，加上i。因此正则表达式为:/[a,e,i,o,u]$/i，最后用test方法去检测字符串strfunction endsWithVowel(str) &#123; return /[a,e,i,o,u]$/i.test(str); &#125; 10、获取指定字符串(正则表达式）给定字符串 str，检查其是否包含 连续3个数字1、如果包含，返回最新出现的 3 个数字的字符串2、如果不包含，返回 false 输入：’9876543’ 输出：987 12345678910111213141516171819function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false;&#125;//题目描述有问题，实际考察的是字符串中是否含有连续的三个任意数字，而不是三个连续的数字。依题，若存在连续的三个任意数字，则返回最早出现的三个数字，若不存在，则返回false。因此需要用到match方法，match()返回的是正则表达式匹配的字符串数组，连续的三个任意数字用正则表达式表示为/\d&#123;3&#125;/。function captureThreeNumbers(str) &#123; //声明一个数组保存匹配的字符串结果 var arr = str.match(/\d&#123;3&#125;/); //如果arr存在目标结果，则返回第一个元素，即最早出现的目标结果 if(arr) return arr[0]; else return false; &#125; 11、判断是否符合指定格式 (正则表达式）给定字符串 str，检查其是否符合如下格式1、XXX-XXX-XXXX2、其中 X 为 Number 类型 输入：’800-555-1212’ 输出：true 1234//本题需要注意格式，开头^和结尾$必须加上来限定字符串，3个数可表示为\d&#123;3&#125;，4个数则为\d&#123;4&#125;，&#123;n&#125;表示前面内容出现的次数。正则表达式可写作/^\d&#123;3&#125;-\d&#123;3&#125;-\d&#123;4&#125;$/，有相同部分\d&#123;3&#125;-，因此也可写作/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/function matchesPattern(str) &#123; return/^(\d&#123;3&#125;-)&#123;2&#125;\d&#123;4&#125;$/.test(str);&#125; 12、判断是否符合 USD 格式 (正则表达式）12345678给定字符串 str，检查其是否符合美元书写格式1、以 $ 开始2、整数部分，从个位起，满 3 个数字用 , 分隔3、如果为小数，则小数部分长度为 24、正确的格式如：$1,023,032.03 或者 $2.03，错误的格式如：$3,432,12.12 或者 $34,344.3输入：&apos;$20,933,209.93&apos;输出：true 12345678910//本题注意点有必须是USD格式，以$开头，数字结尾，$和小数点的转义。首先，开头必是$，而正则表达式中$表示结尾，需要进行转义，因此开头为^\$然后$后必然接数字，并且最少一位，最多三位数，可用&#123;m,n&#125;表示,最少m位，最多n位，因此此段为\d&#123;1,3&#125;接着，后面如还有数，则必然有，分隔，并且后面必有3个数，类似于，XXX的格式会出现0或者n次，因此此段可表示为(,\d&#123;3&#125;)*最后，如有小数部分，则注意对小数点进行转义，此段可表示为(\.\d&#123;2&#125;)?因此，最后的正则表达式为/^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/使用test方法去检测strfunction isUSD(str) &#123; return /^\$\d&#123;1,3&#125;(,\d&#123;3&#125;)*(\.\d&#123;2&#125;)?$/.test(str);&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在window把自己的项目上传到github]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%9C%A8window%E6%8A%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[1.首先简单粗暴的在GitHub上创建自己的库： 2.创建仓库成功后看下图，复制下图这个地址，这是这个仓库的地址，我们项目要传到这里来 3.然后下载git，网上有很多教程（相信自己可以看得懂），安装后运行cd进入到自己的项目目录里（如下图）： 4.然后输入git init，如下图所示，这个意思是在当前项目的目录中生成本地的git管理（会发现在当前目录下多了一个.git文件夹） 第二步： 输入git add . 这个是将项目上所有的文件添加到仓库中的意思，如果想添加某个特定的文件，只需把 . 换成这个特定的文件名即可，记住add和点号中间要有空格。 第三步： 输入git commit -m “first commit”，表示你对这次提交的注释，双引号里面的内容可以根据个人的需要更改。 第四步： 输入git remote add origin https://自己的仓库url地址（上面有说到） 将本地的仓库关联到github上， 第五步： 输入git pull –rebase origin master 使得远程库与本地库一致，我们把远程库同步到本地库就可以了 第六步： 输入git push -u origin master，这是把代码上传到github仓库的意思 5.执行完后，如果没有异常，会等待几秒，然后跳出一个让你输入Username和Password 的窗口，你只要输入 github的登录账号和密码就行了。 如果你之前你已经登陆过，那么就跳过上面步骤，直接等待下图就可以了： 这个是上传进度，这个过程可能有点慢，有时候大的项目要得等个10几分钟，之后去检查GitHub的仓库里有没有就可以了。 本次分享来源于自己的实践，参考了文章：https://blog.csdn.net/wu2374633583/article/details/79130984]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计网页中标签出现的个数]]></title>
    <url>%2F2019%2F04%2F06%2F%E7%BB%9F%E8%AE%A1%E7%BD%91%E9%A1%B5%E4%B8%AD%E6%A0%87%E7%AD%BE%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[废话不多说直接上代码吧： 12345678910111213//获取所有标签 var doms = document.getElementsByTagName("*"); //去重 var obj =&#123;&#125; var ret =[] for(var j =0;j&lt;doms.length;j++)&#123; var name = doms[j].nodeName if(!obj[name])&#123; ret.push(name) obj[name]=true &#125; &#125; console.log(ret.length)]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2019%2F04%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to CAN7! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>GitHub Pages</tag>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是如何建立这个博客的！]]></title>
    <url>%2F2019%2F03%2F23%2F%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AF%9E%E7%94%9F%2F</url>
    <content type="text"><![CDATA[本次学习完全依赖于这位不知名大佬的文章： 2018，你该搭建自己的博客了！*https://juejin.im/entry/5a574864f265da3e3c6c1217*]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>git管理</tag>
      </tags>
  </entry>
</search>
